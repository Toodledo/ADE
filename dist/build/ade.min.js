/* =========================================================
    Modifications made by https://github.com/Toodledo/ADE

    1) Modified regular expressions to match more user inputs

 * ========================================================= */

/**
 * Version: 1.0 Alpha-1 
 * Build Date: 13-Nov-2007
 * Copyright (c) 2006-2007, Coolite Inc. (http://www.coolite.com/). All rights reserved.
 * License: Licensed under The MIT License. See license.txt and http://www.datejs.com/license/. 
 * Website: http://www.datejs.com/ or http://www.coolite.com/datejs/
 */
 

var DateJSLoadCultureInfo = function(language)
{
    if (language.toLowerCase() == "en-us" || language.toLowerCase() == "en")
    {
        Date.CultureInfo = {
            /* Culture Name */
            name: "en-US",
            englishName: "English (United States)",
            nativeName: "English (United States)",

            /* Day Name Strings */
            dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            abbreviatedDayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            shortestDayNames: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
            firstLetterDayNames: ["S", "M", "T", "W", "T", "F", "S"],

            /* Month Name Strings */
            monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            abbreviatedMonthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],

            /* AM/PM Designators */
            amDesignator: "AM",
            pmDesignator: "PM",

            firstDayOfWeek: 0,
            twoDigitYearMax: 2029,

            /**
             * The dateElementOrder is based on the order of the 
             * format specifiers in the formatPatterns.DatePattern. 
             *
             * Example:
             <pre>
             shortDatePattern    dateElementOrder
             ------------------  ---------------- 
             "M/d/yyyy"          "mdy"
             "dd/MM/yyyy"        "dmy"
             "yyyy-MM-dd"        "ymd"
             </pre>
             *
             * The correct dateElementOrder is required by the parser to
             * determine the expected order of the date elements in the
             * string being parsed.
             */
            dateElementOrder: "mdy",

            /* Standard date and time format patterns */
            formatPatterns: {
                shortDate: "M/d/yyyy",
                longDate: "dddd, MMMM dd, yyyy",
                shortTime: "h:mm tt",
                longTime: "h:mm:ss tt",
                fullDateTime: "dddd, MMMM dd, yyyy h:mm:ss tt",
                sortableDateTime: "yyyy-MM-ddTHH:mm:ss",
                universalSortableDateTime: "yyyy-MM-dd HH:mm:ssZ",
                rfc1123: "ddd, dd MMM yyyy HH:mm:ss GMT",
                monthDay: "MMMM dd",
                yearMonth: "MMMM, yyyy"
            }
        };
    }
    else
    {
        Date.CultureInfo = {
            /* Culture Name */
            name: "en-GB",
            englishName: "English (United Kingdom)",
            nativeName: "English (United Kingdom)",

            /* Day Name Strings */
            dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            abbreviatedDayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            shortestDayNames: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
            firstLetterDayNames: ["S", "M", "T", "W", "T", "F", "S"],

            /* Month Name Strings */
            monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            abbreviatedMonthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],

            /* AM/PM Designators */
            amDesignator: "AM",
            pmDesignator: "PM",

            firstDayOfWeek: 1,
            twoDigitYearMax: 2029,

            /**
             * The dateElementOrder is based on the order of the 
             * format specifiers in the formatPatterns.DatePattern. 
             *
             * Example:
             <pre>
             shortDatePattern    dateElementOrder
             ------------------  ---------------- 
             "M/d/yyyy"          "mdy"
             "dd/MM/yyyy"        "dmy"
             "yyyy-MM-dd"        "ymd"
             </pre>
             *
             * The correct dateElementOrder is required by the parser to
             * determine the expected order of the date elements in the
             * string being parsed.
             */
            dateElementOrder: "dmy",

            /* Standard date and time format patterns */
            formatPatterns: {
                shortDate: "dd/MM/yyyy",
                longDate: "dd MMMM yyyy",
                shortTime: "HH:mm",
                longTime: "HH:mm:ss",
                fullDateTime: "dd MMMM yyyy HH:mm:ss",
                sortableDateTime: "yyyy-MM-ddTHH:mm:ss",
                universalSortableDateTime: "yyyy-MM-dd HH:mm:ssZ",
                rfc1123: "ddd, dd MMM yyyy HH:mm:ss GMT",
                monthDay: "dd MMMM",
                yearMonth: "MMMM yyyy"
            }
        };
    }
};
DateJSLoadCultureInfo(window.navigator.userLanguage || window.navigator.language);

/**
     * NOTE: If a string format is not parsing correctly, but
     * you would expect it parse, the problem likely lies below. 
     * 
     * The following regex patterns control most of the string matching
     * within the parser.
     * 
     * The Month name and Day name patterns were automatically generated
     * and in general should be (mostly) correct. 
     *
     * Beyond the month and day name patterns are natural language strings.
     * Example: "next", "today", "months"
     *
     * These natural language string may NOT be correct for this culture. 
     * If they are not correct, please translate and edit this file
     * providing the correct regular expression pattern. 
     *
     * If you modify this file, please post your revised CultureInfo file
     * to the Datejs Forum located at http://www.datejs.com/forums/.
     *
     * Please mark the subject of the post with [CultureInfo]. Example:
     *    Subject: [CultureInfo] Translated "da-DK" Danish(Denmark)
     * 
     * We will add the modified patterns to the master source files.
     *
     * As well, please review the list of "Future Strings" section below. 
     */
if (Date.CultureInfo)
{
    Date.CultureInfo.regexPatterns = {
        jan: /^jan(uary)?/i,
        feb: /^feb(ruary)?/i,
        mar: /^mar(ch)?/i,
        apr: /^apr(il)?/i,
        may: /^may/i,
        jun: /^jun(e)?/i,
        jul: /^jul(y)?/i,
        aug: /^aug(ust)?/i,
        sep: /^sep(t(ember)?)?/i,
        oct: /^oct(ober)?/i,
        nov: /^nov(ember)?/i,
        dec: /^dec(ember)?/i,

        sun: /^su(n(day)?)?/i,
        mon: /^mo(n(day)?)?/i,
        tue: /^tu(e(s(day)?)?)?/i,
        wed: /^we(d(nesday)?)?/i,
        thu: /^th(u(r(s(day)?)?)?)?/i,
        fri: /^fr(i(day)?)?/i,
        sat: /^sa(t(urday)?)?/i,

		//numDayOf: /^[1-4].*of.*/i,
        lastDayOf: /^(last day of)|(last of)/i,
        firstDayOf: /^(first day of)|(first of)|(1st( day)? of)|first|1st/i,
        future: /^next/i,
        past: /^last|past|prev(ious)?/i,
        add: /^(\+|aft(er)?|from|hence|in)/i,
        subtract: /^(\-|bef(ore)?|ago)/i,

        yesterday: /^yes(t(erday)?)?/i,
        today: /^t(od(ay)?)?/i,
        tomorrow: /^tom(orrow)?/i,
        now: /^n(ow)?/i,

        millisecond: /^ms|milli(second)?s?/i,
        second: /^sec(ond)?s?/i,
        minute: /^mn|min(ute)?s?/i,
        hour: /^h(our)?s?/i,
        week: /^w(eek)?s?/i,
        month: /^m((on)?th)?s?/i,
        day: /^d(ay)?s?/i,
        year: /^yr(s)?|(y(ear)?s?)/i,

        shortMeridian: /^(a|p)/i,
        longMeridian: /^(a\.?m?\.?|p\.?m?\.?)/i,
        timezone: /^((e(s|d)t|c(s|d)t|m(s|d)t|p(s|d)t)|((gmt)?\s*(\+|\-)\s*\d\d\d\d?)|gmt|utc)/i,
        ordinalSuffix: /^\s*(st|nd|rd|th)/i,
        timeContext: /^\s*(\:|a(?!u|p)|p)/i
    };

    Date.CultureInfo.timezones = [{ name: "UTC", offset: "-000" }, { name: "GMT", offset: "-000" }, { name: "EST", offset: "-0500" }, { name: "EDT", offset: "-0400" }, { name: "CST", offset: "-0600" }, { name: "CDT", offset: "-0500" }, { name: "MST", offset: "-0700" }, { name: "MDT", offset: "-0600" }, { name: "PST", offset: "-0800" }, { name: "PDT", offset: "-0700" }];
};

/********************
 ** Future Strings **
 ********************
 * 
 * The following list of strings may not be currently being used, but 
 * may be incorporated into the Datejs library later. 
 *
 * We would appreciate any help translating the strings below.
 * 
 * If you modify this file, please post your revised CultureInfo file
 * to the Datejs Forum located at http://www.datejs.com/forums/.
 *
 * Please mark the subject of the post with [CultureInfo]. Example:
 *    Subject: [CultureInfo] Translated "da-DK" Danish(Denmark)b
 *
 * English Name        Translated
 * ------------------  -----------------
 * about               about
 * ago                 ago
 * date                date
 * time                time
 * calendar            calendar
 * show                show
 * hourly              hourly
 * daily               daily
 * weekly              weekly
 * bi-weekly           bi-weekly
 * fortnight           fortnight
 * monthly             monthly
 * bi-monthly          bi-monthly
 * quarter             quarter
 * quarterly           quarterly
 * yearly              yearly
 * annual              annual
 * annually            annually
 * annum               annum
 * again               again
 * between             between
 * after               after
 * from now            from now
 * repeat              repeat
 * times               times
 * per                 per
 * min (abbrev minute) min
 * morning             morning
 * noon                noon
 * night               night
 * midnight            midnight
 * mid-night           mid-night
 * evening             evening
 * final               final
 * future              future
 * spring              spring
 * summer              summer
 * fall                fall
 * winter              winter
 * end of              end of
 * end                 end
 * long                long
 * short               short
 */

/**
* @version: 1.0 Alpha-1
* @author: Coolite Inc. http://www.coolite.com/
* @date: 2008-04-13
* @copyright: Copyright (c) 2006-2008, Coolite Inc. (http://www.coolite.com/). All rights reserved.
* @license: Licensed under The MIT License. See license.txt and http://www.datejs.com/license/. 
* @website: http://www.datejs.com/
*/

(function () {
    var $D = Date,
        $P = $D.prototype,
        $C = Date.CultureInfo,
        p = function (s, l) {
            if (!l) {
                l = 2;
            }
            return ("000" + s).slice(l * -1);
        };

    /**
     * Resets the time of this Date object to 12:00 AM (00:00), which is the start of the day.
     * @param {Boolean}  .clone() this date instance before clearing Time
     * @return {Date}    this
     */
    $P.clearTime = function () {
        this.setHours(0);
        this.setMinutes(0);
        this.setSeconds(0);
        this.setMilliseconds(0);
        return this;
    };

    /**
     * Resets the time of this Date object to the current time ('now').
     * @return {Date}    this
     */
    $P.setTimeToNow = function () {
        var n = new Date();
        this.setHours(n.getHours());
        this.setMinutes(n.getMinutes());
        this.setSeconds(n.getSeconds());
        this.setMilliseconds(n.getMilliseconds());
        return this;
    };

    /** 
     * Gets a date that is set to the current date. The time is set to the start of the day (00:00 or 12:00 AM).
     * @return {Date}    The current date.
     */
    $D.today = function () {
        return new Date().clearTime();
    };

    /**
     * Compares the first date to the second date and returns an number indication of their relative values.  
     * @param {Date}     First Date object to compare [Required].
     * @param {Date}     Second Date object to compare to [Required].
     * @return {Number}  -1 = date1 is lessthan date2. 0 = values are equal. 1 = date1 is greaterthan date2.
     */
    $D.compare = function (date1, date2) {
        if (isNaN(date1) || isNaN(date2)) {
            throw new Error(date1 + " - " + date2);
        } else if (date1 instanceof Date && date2 instanceof Date) {
            return (date1 < date2) ? -1 : (date1 > date2) ? 1 : 0;
        } else {
            throw new TypeError(date1 + " - " + date2);
        }
    };

    /**
     * Compares the first Date object to the second Date object and returns true if they are equal.  
     * @param {Date}     First Date object to compare [Required]
     * @param {Date}     Second Date object to compare to [Required]
     * @return {Boolean} true if dates are equal. false if they are not equal.
     */
    $D.equals = function (date1, date2) {
        return (date1.compareTo(date2) === 0);
    };

    /**
     * Gets the day number (0-6) if given a CultureInfo specific string which is a valid dayName, abbreviatedDayName or shortestDayName (two char).
     * @param {String}   The name of the day (eg. "Monday, "Mon", "tuesday", "tue", "We", "we").
     * @return {Number}  The day number
     */
    $D.getDayNumberFromName = function (name) {
        var n = Date.CultureInfo.dayNames, m = Date.CultureInfo.abbreviatedDayNames, o = Date.CultureInfo.shortestDayNames, s = name.toLowerCase();
        for (var i = 0; i < n.length; i++) {
            if (n[i].toLowerCase() == s || m[i].toLowerCase() == s || o[i].toLowerCase() == s) {
                return i;
            }
        }
        return -1;
    };

    /**
     * Gets the month number (0-11) if given a Culture Info specific string which is a valid monthName or abbreviatedMonthName.
     * @param {String}   The name of the month (eg. "February, "Feb", "october", "oct").
     * @return {Number}  The day number
     */
    $D.getMonthNumberFromName = function (name) {
        var n = Date.CultureInfo.monthNames, m = Date.CultureInfo.abbreviatedMonthNames, s = name.toLowerCase();
        for (var i = 0; i < n.length; i++) {
            if (n[i].toLowerCase() == s || m[i].toLowerCase() == s) {
                return i;
            }
        }
        return -1;
    };

    /**
     * Determines if the current date instance is within a LeapYear.
     * @param {Number}   The year.
     * @return {Boolean} true if date is within a LeapYear, otherwise false.
     */
    $D.isLeapYear = function (year) {
        return ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0);
    };

    /**
     * Gets the number of days in the month, given a year and month value. Automatically corrects for LeapYear.
     * @param {Number}   The year.
     * @param {Number}   The month (0-11).
     * @return {Number}  The number of days in the month.
     */
    $D.getDaysInMonth = function (year, month) {
        return [31, ($D.isLeapYear(year) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
    };

    $D.getTimezoneAbbreviation = function (offset) {
        var z = Date.CultureInfo.timezones, p;
        for (var i = 0; i < z.length; i++) {
            if (z[i].offset === offset) {
                return z[i].name;
            }
        }
        return null;
    };

    $D.getTimezoneOffset = function (name) {
        var z = Date.CultureInfo.timezones, p;
        for (var i = 0; i < z.length; i++) {
            if (z[i].name === name.toUpperCase()) {
                return z[i].offset;
            }
        }
        return null;
    };

    /**
     * Returns a new Date object that is an exact date and time copy of the original instance.
     * @return {Date}    A new Date instance
     */
    $P.clone = function () {
        return new Date(this.getTime());
    };

    /**
     * Compares this instance to a Date object and returns an number indication of their relative values.  
     * @param {Date}     Date object to compare [Required]
     * @return {Number}  -1 = this is lessthan date. 0 = values are equal. 1 = this is greaterthan date.
     */
    $P.compareTo = function (date) {
        return Date.compare(this, date);
    };

    /**
     * Compares this instance to another Date object and returns true if they are equal.  
     * @param {Date}     Date object to compare. If no date to compare, new Date() [now] is used.
     * @return {Boolean} true if dates are equal. false if they are not equal.
     */
    $P.equals = function (date) {
        return Date.equals(this, date || new Date());
    };

    /**
     * Determines if this instance is between a range of two dates or equal to either the start or end dates.
     * @param {Date}     Start of range [Required]
     * @param {Date}     End of range [Required]
     * @return {Boolean} true is this is between or equal to the start and end dates, else false
     */
    $P.between = function (start, end) {
        return this.getTime() >= start.getTime() && this.getTime() <= end.getTime();
    };

    /**
     * Determines if this date occurs after the date to compare to.
     * @param {Date}     Date object to compare. If no date to compare, new Date() ("now") is used.
     * @return {Boolean} true if this date instance is greater than the date to compare to (or "now"), otherwise false.
     */
    $P.isAfter = function (date) {
        return this.compareTo(date || new Date()) === 1;
    };

    /**
     * Determines if this date occurs before the date to compare to.
     * @param {Date}     Date object to compare. If no date to compare, new Date() ("now") is used.
     * @return {Boolean} true if this date instance is less than the date to compare to (or "now").
     */
    $P.isBefore = function (date) {
        return (this.compareTo(date || new Date()) === -1);
    };

    /**
     * Determines if the current Date instance occurs today.
     * @return {Boolean} true if this date instance is 'today', otherwise false.
     */

    /**
     * Determines if the current Date instance occurs on the same Date as the supplied 'date'. 
     * If no 'date' to compare to is provided, the current Date instance is compared to 'today'. 
     * @param {date}     Date object to compare. If no date to compare, the current Date ("now") is used.
     * @return {Boolean} true if this Date instance occurs on the same Day as the supplied 'date'.
     */
    $P.isToday = $P.isSameDay = function (date) {
        return this.clone().clearTime().equals((date || new Date()).clone().clearTime());
    };

    /**
     * Adds the specified number of milliseconds to this instance. 
     * @param {Number}   The number of milliseconds to add. The number can be positive or negative [Required]
     * @return {Date}    this
     */
    $P.addMilliseconds = function (value) {
        this.setMilliseconds(this.getMilliseconds() + value * 1);
        return this;
    };

    /**
     * Adds the specified number of seconds to this instance. 
     * @param {Number}   The number of seconds to add. The number can be positive or negative [Required]
     * @return {Date}    this
     */
    $P.addSeconds = function (value) {
        return this.addMilliseconds(value * 1000);
    };

    /**
     * Adds the specified number of seconds to this instance. 
     * @param {Number}   The number of seconds to add. The number can be positive or negative [Required]
     * @return {Date}    this
     */
    $P.addMinutes = function (value) {
        return this.addMilliseconds(value * 60000); /* 60*1000 */
    };

    /**
     * Adds the specified number of hours to this instance. 
     * @param {Number}   The number of hours to add. The number can be positive or negative [Required]
     * @return {Date}    this
     */
    $P.addHours = function (value) {
        return this.addMilliseconds(value * 3600000); /* 60*60*1000 */
    };

    /**
     * Adds the specified number of days to this instance. 
     * @param {Number}   The number of days to add. The number can be positive or negative [Required]
     * @return {Date}    this
     */
    $P.addDays = function (value) {
        this.setDate(this.getDate() + value * 1);
        return this;
    };

    /**
     * Adds the specified number of weeks to this instance. 
     * @param {Number}   The number of weeks to add. The number can be positive or negative [Required]
     * @return {Date}    this
     */
    $P.addWeeks = function (value) {
        return this.addDays(value * 7);
    };

    /**
     * Adds the specified number of months to this instance. 
     * @param {Number}   The number of months to add. The number can be positive or negative [Required]
     * @return {Date}    this
     */
    $P.addMonths = function (value) {
        var n = this.getDate();
        this.setDate(1);
        this.setMonth(this.getMonth() + value * 1);
        this.setDate(Math.min(n, $D.getDaysInMonth(this.getFullYear(), this.getMonth())));
        return this;
    };

    /**
     * Adds the specified number of years to this instance. 
     * @param {Number}   The number of years to add. The number can be positive or negative [Required]
     * @return {Date}    this
     */
    $P.addYears = function (value) {
        return this.addMonths(value * 12);
    };

    /**
     * Adds (or subtracts) to the value of the years, months, weeks, days, hours, minutes, seconds, milliseconds of the date instance using given configuration object. Positive and Negative values allowed.
     * Example
    <pre><code>
    Date.today().add( { days: 1, months: 1 } )
     
    new Date().add( { years: -1 } )
    </code></pre> 
     * @param {Object}   Configuration object containing attributes (months, days, etc.)
     * @return {Date}    this
     */
    $P.add = function (config) {
        if (typeof config == "number") {
            this._orient = config;
            return this;
        }

        var x = config;

        if (x.milliseconds) {
            this.addMilliseconds(x.milliseconds);
        }
        if (x.seconds) {
            this.addSeconds(x.seconds);
        }
        if (x.minutes) {
            this.addMinutes(x.minutes);
        }
        if (x.hours) {
            this.addHours(x.hours);
        }
        if (x.weeks) {
            this.addWeeks(x.weeks);
        }
        if (x.months) {
            this.addMonths(x.months);
        }
        if (x.years) {
            this.addYears(x.years);
        }
        if (x.days) {
            this.addDays(x.days);
        }
        return this;
    };

    var $y, $m, $d;

    /**
     * Get the week number. Week one (1) is the week which contains the first Thursday of the year. Monday is considered the first day of the week.
     * This algorithm is a JavaScript port of the work presented by Claus T�ndering at http://www.tondering.dk/claus/cal/node8.html#SECTION00880000000000000000
     * .getWeek() Algorithm Copyright (c) 2008 Claus Tondering.
     * The .getWeek() function does NOT convert the date to UTC. The local datetime is used. Please use .getISOWeek() to get the week of the UTC converted date.
     * @return {Number}  1 to 53
     */
    $P.getWeek = function () {
        var a, b, c, d, e, f, g, n, s, w;

        $y = (!$y) ? this.getFullYear() : $y;
        $m = (!$m) ? this.getMonth() + 1 : $m;
        $d = (!$d) ? this.getDate() : $d;

        if ($m <= 2) {
            a = $y - 1;
            b = (a / 4 | 0) - (a / 100 | 0) + (a / 400 | 0);
            c = ((a - 1) / 4 | 0) - ((a - 1) / 100 | 0) + ((a - 1) / 400 | 0);
            s = b - c;
            e = 0;
            f = $d - 1 + (31 * ($m - 1));
        } else {
            a = $y;
            b = (a / 4 | 0) - (a / 100 | 0) + (a / 400 | 0);
            c = ((a - 1) / 4 | 0) - ((a - 1) / 100 | 0) + ((a - 1) / 400 | 0);
            s = b - c;
            e = s + 1;
            f = $d + ((153 * ($m - 3) + 2) / 5) + 58 + s;
        }

        g = (a + b) % 7;
        d = (f + g - e) % 7;
        n = (f + 3 - d) | 0;

        if (n < 0) {
            w = 53 - ((g - s) / 5 | 0);
        } else if (n > 364 + s) {
            w = 1;
        } else {
            w = (n / 7 | 0) + 1;
        }

        $y = $m = $d = null;

        return w;
    };

    /**
     * Get the ISO 8601 week number. Week one ("01") is the week which contains the first Thursday of the year. Monday is considered the first day of the week.
     * The .getISOWeek() function does convert the date to it's UTC value. Please use .getWeek() to get the week of the local date.
     * @return {String}  "01" to "53"
     */
    $P.getISOWeek = function () {
        $y = this.getUTCFullYear();
        $m = this.getUTCMonth() + 1;
        $d = this.getUTCDate();
        return p(this.getWeek());
    };

    /**
     * Moves the date to Monday of the week set. Week one (1) is the week which contains the first Thursday of the year.
     * @param {Number}   A Number (1 to 53) that represents the week of the year.
     * @return {Date}    this
     */
    $P.setWeek = function (n) {
        return this.moveToDayOfWeek(1).addWeeks(n - this.getWeek());
    };

    // private
    var validate = function (n, min, max, name) {
        if (typeof n == "undefined") {
            return false;
        } else if (typeof n != "number") {
            throw new TypeError(n + " is not a Number.");
        } else if (n < min || n > max) {
            throw new RangeError(n + " is not a valid value for " + name + ".");
        }
        return true;
    };

    /**
     * Validates the number is within an acceptable range for milliseconds [0-999].
     * @param {Number}   The number to check if within range.
     * @return {Boolean} true if within range, otherwise false.
     */
    $D.validateMillisecond = function (value) {
        return validate(value, 0, 999, "millisecond");
    };

    /**
     * Validates the number is within an acceptable range for seconds [0-59].
     * @param {Number}   The number to check if within range.
     * @return {Boolean} true if within range, otherwise false.
     */
    $D.validateSecond = function (value) {
        return validate(value, 0, 59, "second");
    };

    /**
     * Validates the number is within an acceptable range for minutes [0-59].
     * @param {Number}   The number to check if within range.
     * @return {Boolean} true if within range, otherwise false.
     */
    $D.validateMinute = function (value) {
        return validate(value, 0, 59, "minute");
    };

    /**
     * Validates the number is within an acceptable range for hours [0-23].
     * @param {Number}   The number to check if within range.
     * @return {Boolean} true if within range, otherwise false.
     */
    $D.validateHour = function (value) {
        return validate(value, 0, 23, "hour");
    };

    /**
     * Validates the number is within an acceptable range for the days in a month [0-MaxDaysInMonth].
     * @param {Number}   The number to check if within range.
     * @return {Boolean} true if within range, otherwise false.
     */
    $D.validateDay = function (value, year, month) {
        return validate(value, 1, $D.getDaysInMonth(year, month), "day");
    };

    /**
     * Validates the number is within an acceptable range for months [0-11].
     * @param {Number}   The number to check if within range.
     * @return {Boolean} true if within range, otherwise false.
     */
    $D.validateMonth = function (value) {
        return validate(value, 0, 11, "month");
    };

    /**
     * Validates the number is within an acceptable range for years.
     * @param {Number}   The number to check if within range.
     * @return {Boolean} true if within range, otherwise false.
     */
    $D.validateYear = function (value) {
        return validate(value, 0, 9999, "year");
    };

    /**
     * Set the value of year, month, day, hour, minute, second, millisecond of date instance using given configuration object.
     * Example
    <pre><code>
    Date.today().set( { day: 20, month: 1 } )

    new Date().set( { millisecond: 0 } )
    </code></pre>
     * 
     * @param {Object}   Configuration object containing attributes (month, day, etc.)
     * @return {Date}    this
     */
    $P.set = function (config) {
        if ($D.validateMillisecond(config.millisecond)) {
            this.addMilliseconds(config.millisecond - this.getMilliseconds());
        }

        if ($D.validateSecond(config.second)) {
            this.addSeconds(config.second - this.getSeconds());
        }

        if ($D.validateMinute(config.minute)) {
            this.addMinutes(config.minute - this.getMinutes());
        }

        if ($D.validateHour(config.hour)) {
            this.addHours(config.hour - this.getHours());
        }

        if ($D.validateMonth(config.month)) {
            this.addMonths(config.month - this.getMonth());
        }

        if ($D.validateYear(config.year)) {
            this.addYears(config.year - this.getFullYear());
        }

        /* day has to go last because you can't validate the day without first knowing the month */
        if ($D.validateDay(config.day, this.getFullYear(), this.getMonth())) {
            this.addDays(config.day - this.getDate());
        }

        if (config.timezone) {
            this.setTimezone(config.timezone);
        }

        if (config.timezoneOffset) {
            this.setTimezoneOffset(config.timezoneOffset);
        }

        if (config.week && validate(config.week, 0, 53, "week")) {
            this.setWeek(config.week);
        }
        
        cDate = new Date();

        if (config.year == undefined && (config.month < cDate.getMonth() || (config.month == cDate.getMonth() && config.day < cDate.getDate())))
            this.addYears(1);

        return this;
    };

    /**
     * Moves the date to the first day of the month.
     * @return {Date}    this
     */
    $P.moveToFirstDayOfMonth = function () {
        return this.set({ day: 1 });
    };

    /**
     * Moves the date to the last day of the month.
     * @return {Date}    this
     */
    $P.moveToLastDayOfMonth = function () {
        return this.set({ day: $D.getDaysInMonth(this.getFullYear(), this.getMonth()) });
    };

    /**
     * Moves the date to the next n'th occurrence of the dayOfWeek starting from the beginning of the month. The number (-1) is a magic number and will return the last occurrence of the dayOfWeek in the month.
     * @param {Number}   The dayOfWeek to move to
     * @param {Number}   The n'th occurrence to move to. Use (-1) to return the last occurrence in the month
     * @return {Date}    this
     */
    $P.moveToNthOccurrence = function (dayOfWeek, occurrence) {
        var shift = 0;
        if (occurrence > 0) {
            shift = occurrence - 1;
        }
        else if (occurrence === -1) {
            this.moveToLastDayOfMonth();
            if (this.getDay() !== dayOfWeek) {
                this.moveToDayOfWeek(dayOfWeek, -1);
            }
            return this;
        }
        return this.moveToFirstDayOfMonth().addDays(-1).moveToDayOfWeek(dayOfWeek, +1).addWeeks(shift);
    };

    /**
     * Move to the next or last dayOfWeek based on the orient value.
     * @param {Number}   The dayOfWeek to move to
     * @param {Number}   Forward (+1) or Back (-1). Defaults to +1. [Optional]
     * @return {Date}    this
     */
    $P.moveToDayOfWeek = function (dayOfWeek, orient) {
        var diff = (dayOfWeek - this.getDay() + 7 * (orient || +1)) % 7;
        return this.addDays((diff === 0) ? diff += 7 * (orient || +1) : diff);
    };

    /**
     * Move to the next or last month based on the orient value.
     * @param {Number}   The month to move to. 0 = January, 11 = December
     * @param {Number}   Forward (+1) or Back (-1). Defaults to +1. [Optional]
     * @return {Date}    this
     */
    $P.moveToMonth = function (month, orient) {
        var diff = (month - this.getMonth() + 12 * (orient || +1)) % 12;
        return this.addMonths((diff === 0) ? diff += 12 * (orient || +1) : diff);
    };

    /**
     * Get the Ordinal day (numeric day number) of the year, adjusted for leap year.
     * @return {Number} 1 through 365 (366 in leap years)
     */
    $P.getOrdinalNumber = function () {
        return Math.ceil((this.clone().clearTime() - new Date(this.getFullYear(), 0, 1)) / 86400000) + 1;
    };

    /**
     * Get the time zone abbreviation of the current date.
     * @return {String} The abbreviated time zone name (e.g. "EST")
     */
    $P.getTimezone = function () {
        return $D.getTimezoneAbbreviation(this.getUTCOffset());
    };

    $P.setTimezoneOffset = function (offset) {
        var here = this.getTimezoneOffset(), there = Number(offset) * -6 / 10;
        return this.addMinutes(there - here);
    };

    $P.setTimezone = function (offset) {
        return this.setTimezoneOffset($D.getTimezoneOffset(offset));
    };

    /**
     * Indicates whether Daylight Saving Time is observed in the current time zone.
     * @return {Boolean} true|false
     */
    $P.hasDaylightSavingTime = function () {
        return (Date.today().set({ month: 0, day: 1 }).getTimezoneOffset() !== Date.today().set({ month: 6, day: 1 }).getTimezoneOffset());
    };

    /**
     * Indicates whether this Date instance is within the Daylight Saving Time range for the current time zone.
     * @return {Boolean} true|false
     */
    $P.isDaylightSavingTime = function () {
        return Date.today().set({ month: 0, day: 1 }).getTimezoneOffset() != this.getTimezoneOffset();
    };

    /**
     * Get the offset from UTC of the current date.
     * @return {String} The 4-character offset string prefixed with + or - (e.g. "-0500")
     */
    $P.getUTCOffset = function () {
        var n = this.getTimezoneOffset() * -10 / 6, r;
        if (n < 0) {
            r = (n - 10000).toString();
            return r.charAt(0) + r.substr(2);
        } else {
            r = (n + 10000).toString();
            return "+" + r.substr(1);
        }
    };
    
    /**
     * Returns a unix timestamp
     * @return {int}    Number of seconds since epoch: January 01 1970
    */
    $P.toUnixTimestamp = function () {
        return Math.round(this.getTime() / 1000);
    };

    $P.getMonthName = function (month)
    {
    	if (Date.CultureInfo && Date.CultureInfo.monthNames && month >= 0 && month < 12)
    	{
    		return Date.CultureInfo.monthNames[month];
    	}
    	return "";
    };

    /**
     * Returns the number of milliseconds between this date and date.
     * @param {Date} Defaults to now
     * @return {Number} The diff in milliseconds
     */
    $P.getElapsed = function (date) {
        return (date || new Date()) - this;
    };

    if (!$P.toISOString) {
        /**
         * Converts the current date instance into a string with an ISO 8601 format. The date is converted to it's UTC value.
         * @return {String}  ISO 8601 string of date
         */
        $P.toISOString = function () {
            // From http://www.json.org/json.js. Public Domain. 
            function f(n) {
                return n < 10 ? '0' + n : n;
            }

            return '"' + this.getUTCFullYear() + '-' +
                f(this.getUTCMonth() + 1) + '-' +
                f(this.getUTCDate()) + 'T' +
                f(this.getUTCHours()) + ':' +
                f(this.getUTCMinutes()) + ':' +
                f(this.getUTCSeconds()) + 'Z"';
        };
    }

    // private
    $P._toString = $P.toString;

    /**
     * Converts the value of the current Date object to its equivalent string representation.
     * Format Specifiers
    <pre>
    CUSTOM DATE AND TIME FORMAT STRINGS
    Format  Description                                                                  Example
    ------  ---------------------------------------------------------------------------  -----------------------
     s      The seconds of the minute between 0-59.                                      "0" to "59"
     ss     The seconds of the minute with leading zero if required.                     "00" to "59"
     
     m      The minute of the hour between 0-59.                                         "0"  or "59"
     mm     The minute of the hour with leading zero if required.                        "00" or "59"
     
     h      The hour of the day between 1-12.                                            "1"  to "12"
     hh     The hour of the day with leading zero if required.                           "01" to "12"
     
     H      The hour of the day between 0-23.                                            "0"  to "23"
     HH     The hour of the day with leading zero if required.                           "00" to "23"
     
     d      The day of the month between 1 and 31.                                       "1"  to "31"
     dd     The day of the month with leading zero if required.                          "01" to "31"
     ddd    Abbreviated day name. Date.CultureInfo.abbreviatedDayNames.                                "Mon" to "Sun" 
     dddd   The full day name. Date.CultureInfo.dayNames.                                              "Monday" to "Sunday"
     
     M      The month of the year between 1-12.                                          "1" to "12"
     MM     The month of the year with leading zero if required.                         "01" to "12"
     MMM    Abbreviated month name. Date.CultureInfo.abbreviatedMonthNames.                            "Jan" to "Dec"
     MMMM   The full month name. Date.CultureInfo.monthNames.                                          "January" to "December"

     yy     The year as a two-digit number.                                              "99" or "08"
     yyyy   The full four digit year.                                                    "1999" or "2008"
     
     t      Displays the first character of the A.M./P.M. designator.                    "A" or "P"
            Date.CultureInfo.amDesignator or Date.CultureInfo.pmDesignator
     tt     Displays the A.M./P.M. designator.                                           "AM" or "PM"
            Date.CultureInfo.amDesignator or Date.CultureInfo.pmDesignator
     
     S      The ordinal suffix ("st, "nd", "rd" or "th") of the current day.            "st, "nd", "rd" or "th"

|| *Format* || *Description* || *Example* ||
|| d      || The CultureInfo shortDate Format Pattern                                     || "M/d/yyyy" ||
|| D      || The CultureInfo longDate Format Pattern                                      || "dddd, MMMM dd, yyyy" ||
|| F      || The CultureInfo fullDateTime Format Pattern                                  || "dddd, MMMM dd, yyyy h:mm:ss tt" ||
|| m      || The CultureInfo monthDay Format Pattern                                      || "MMMM dd" ||
|| r      || The CultureInfo rfc1123 Format Pattern                                       || "ddd, dd MMM yyyy HH:mm:ss GMT" ||
|| s      || The CultureInfo sortableDateTime Format Pattern                              || "yyyy-MM-ddTHH:mm:ss" ||
|| t      || The CultureInfo shortTime Format Pattern                                     || "h:mm tt" ||
|| T      || The CultureInfo longTime Format Pattern                                      || "h:mm:ss tt" ||
|| u      || The CultureInfo universalSortableDateTime Format Pattern                     || "yyyy-MM-dd HH:mm:ssZ" ||
|| y      || The CultureInfo yearMonth Format Pattern                                     || "MMMM, yyyy" ||
     

    STANDARD DATE AND TIME FORMAT STRINGS
    Format  Description                                                                  Example ("en-US")
    ------  ---------------------------------------------------------------------------  -----------------------
     d      The CultureInfo shortDate Format Pattern                                     "M/d/yyyy"
     D      The CultureInfo longDate Format Pattern                                      "dddd, MMMM dd, yyyy"
     F      The CultureInfo fullDateTime Format Pattern                                  "dddd, MMMM dd, yyyy h:mm:ss tt"
     m      The CultureInfo monthDay Format Pattern                                      "MMMM dd"
     r      The CultureInfo rfc1123 Format Pattern                                       "ddd, dd MMM yyyy HH:mm:ss GMT"
     s      The CultureInfo sortableDateTime Format Pattern                              "yyyy-MM-ddTHH:mm:ss"
     t      The CultureInfo shortTime Format Pattern                                     "h:mm tt"
     T      The CultureInfo longTime Format Pattern                                      "h:mm:ss tt"
     u      The CultureInfo universalSortableDateTime Format Pattern                     "yyyy-MM-dd HH:mm:ssZ"
     y      The CultureInfo yearMonth Format Pattern                                     "MMMM, yyyy"
    </pre>
     * @param {String}   A format string consisting of one or more format spcifiers [Optional].
     * @return {String}  A string representation of the current Date object.
     */
    $P.toString = function (format) {
        var x = this;

        // Standard Date and Time Format Strings. Formats pulled from CultureInfo file and
        // may vary by culture. 
        if (format && format.length == 1) {
            var c = Date.CultureInfo.formatPatterns;
            x.t = x.toString;
            switch (format) {
                case "d":
                    return x.t(c.shortDate);
                case "D":
                    return x.t(c.longDate);
                case "F":
                    return x.t(c.fullDateTime);
                case "m":
                    return x.t(c.monthDay);
                case "r":
                    return x.t(c.rfc1123);
                case "s":
                    return x.t(c.sortableDateTime);
                case "t":
                    return x.t(c.shortTime);
                case "T":
                    return x.t(c.longTime);
                case "u":
                    return x.t(c.universalSortableDateTime);
                case "y":
                    return x.t(c.yearMonth);
            }
        }

        var ord = function (n) {
            switch (n * 1) {
                case 1:
                case 21:
                case 31:
                    return "st";
                case 2:
                case 22:
                    return "nd";
                case 3:
                case 23:
                    return "rd";
                default:
                    return "th";
            }
        };

        return format ? format.replace(/(\\)?(dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|S)/g,
        function (m) {
            if (m.charAt(0) === "\\") {
                return m.replace("\\", "");
            }
            x.h = x.getHours;
            switch (m) {
                case "hh":
                    return p(x.h() < 13 ? (x.h() === 0 ? 12 : x.h()) : (x.h() - 12));
                case "h":
                    return x.h() < 13 ? (x.h() === 0 ? 12 : x.h()) : (x.h() - 12);
                case "HH":
                    return p(x.h());
                case "H":
                    return x.h();
                case "mm":
                    return p(x.getMinutes());
                case "m":
                    return x.getMinutes();
                case "ss":
                    return p(x.getSeconds());
                case "s":
                    return x.getSeconds();
                case "yyyy":
                    return p(x.getFullYear(), 4);
                case "yy":
                    return p(x.getFullYear());
                case "dddd":
                    return Date.CultureInfo.dayNames[x.getDay()];
                case "ddd":
                    return Date.CultureInfo.abbreviatedDayNames[x.getDay()];
                case "dd":
                    return p(x.getDate());
                case "d":
                    return x.getDate();
                case "MMMM":
                    return Date.CultureInfo.monthNames[x.getMonth()];
                case "MMM":
                    return Date.CultureInfo.abbreviatedMonthNames[x.getMonth()];
                case "MM":
                    return p((x.getMonth() + 1));
                case "M":
                    return x.getMonth() + 1;
                case "t":
                    return x.h() < 12 ? Date.CultureInfo.amDesignator.substring(0, 1) : Date.CultureInfo.pmDesignator.substring(0, 1);
                case "tt":
                    return x.h() < 12 ? Date.CultureInfo.amDesignator : Date.CultureInfo.pmDesignator;
                case "S":
                    return ord(x.getDate());
                default:
                    return m;
            }
        }
        ) : this._toString();
    };
}());

/**
 * @version: 1.0 Alpha-1
 * @author: Coolite Inc. http://www.coolite.com/
 * @date: 2008-04-13
 * @copyright: Copyright (c) 2006-2008, Coolite Inc. (http://www.coolite.com/). All rights reserved.
 * @license: Licensed under The MIT License. See license.txt and http://www.datejs.com/license/. 
 * @website: http://www.datejs.com/
 */

/**
 **************************************************************
 ** SugarPak - Domain Specific Language -  Syntactical Sugar **
 **************************************************************
 */

(function () {
    var $D = Date, $P = $D.prototype, $C = $D.CultureInfo, $N = Number.prototype;

    // private
    $P._orient = +1;

    // private
    $P._nth = null;

    // private
    $P._is = false;

    // private
    $P._same = false;

    // private
    $P._isSecond = false;

    // private
    $N._dateElement = "day";

    /** 
     * Moves the date to the next instance of a date as specified by the subsequent date element function (eg. .day(), .month()), month name function (eg. .january(), .jan()) or day name function (eg. .friday(), fri()).
     * Example
    <pre><code>
    Date.today().next().friday();
    Date.today().next().fri();
    Date.today().next().march();
    Date.today().next().mar();
    Date.today().next().week();
    </code></pre>
     * 
     * @return {Date}    date
     */
    $P.next = function () {
        this._orient = +1;
        return this;
    };

    /** 
     * Creates a new Date (Date.today()) and moves the date to the next instance of the date as specified by the subsequent date element function (eg. .day(), .month()), month name function (eg. .january(), .jan()) or day name function (eg. .friday(), fri()).
     * Example
    <pre><code>
    Date.next().friday();
    Date.next().fri();
    Date.next().march();
    Date.next().mar();
    Date.next().week();
    </code></pre>
     * 
     * @return {Date}    date
     */
    $D.next = function () {
        return $D.today().next();
    };

    /** 
     * Moves the date to the previous instance of a date as specified by the subsequent date element function (eg. .day(), .month()), month name function (eg. .january(), .jan()) or day name function (eg. .friday(), fri()).
     * Example
    <pre><code>
    Date.today().last().friday();
    Date.today().last().fri();
    Date.today().last().march();
    Date.today().last().mar();
    Date.today().last().week();
    </code></pre>
     *  
     * @return {Date}    date
     */
    $P.last = $P.prev = $P.previous = function () {
        this._orient = -1;
        return this;
    };

    /** 
     * Creates a new Date (Date.today()) and moves the date to the previous instance of the date as specified by the subsequent date element function (eg. .day(), .month()), month name function (eg. .january(), .jan()) or day name function (eg. .friday(), fri()).
     * Example
    <pre><code>
    Date.last().friday();
    Date.last().fri();
    Date.previous().march();
    Date.prev().mar();
    Date.last().week();
    </code></pre>
     *  
     * @return {Date}    date
     */
    $D.last = $D.prev = $D.previous = function () {
        return $D.today().last();
    };

    /** 
     * Performs a equality check when followed by either a month name, day name or .weekday() function.
     * Example
    <pre><code>
    Date.today().is().friday(); // true|false
    Date.today().is().fri();
    Date.today().is().march();
    Date.today().is().mar();
    </code></pre>
     *  
     * @return {Boolean}    true|false
     */
    $P.is = function () {
        this._is = true;
        return this;
    };

    /** 
     * Determines if two date objects occur on/in exactly the same instance of the subsequent date part function.
     * The function .same() must be followed by a date part function (example: .day(), .month(), .year(), etc).
     *
     * An optional Date can be passed in the date part function. If now date is passed as a parameter, 'Now' is used. 
     *
     * The following example demonstrates how to determine if two dates fall on the exact same day.
     *
     * Example
    <pre><code>
    var d1 = Date.today(); // today at 00:00
    var d2 = new Date();   // exactly now.

    // Do they occur on the same day?
    d1.same().day(d2); // true
    
     // Do they occur on the same hour?
    d1.same().hour(d2); // false, unless d2 hour is '00' (midnight).
    
    // What if it's the same day, but one year apart?
    var nextYear = Date.today().add(1).year();

    d1.same().day(nextYear); // false, because the dates must occur on the exact same day. 
    </code></pre>
     *
     * Scenario: Determine if a given date occurs during some week period 2 months from now. 
     *
     * Example
    <pre><code>
    var future = Date.today().add(2).months();
    return someDate.same().week(future); // true|false;
    </code></pre>
     *  
     * @return {Boolean}    true|false
     */
    $P.same = function () {
        this._same = true;
        this._isSecond = false;
        return this;
    };

    /** 
     * Determines if the current date/time occurs during Today. Must be preceded by the .is() function.
     * Example
    <pre><code>
    someDate.is().today();    // true|false
    new Date().is().today();  // true
    Date.today().is().today();// true
    Date.today().add(-1).day().is().today(); // false
    </code></pre>
     *  
     * @return {Boolean}    true|false
     */
    $P.today = function () {
        return this.same().day();
    };

    /** 
     * Determines if the current date is a weekday. This function must be preceded by the .is() function.
     * Example
    <pre><code>
    Date.today().is().weekday(); // true|false
    </code></pre>
     *  
     * @return {Boolean}    true|false
     */
    $P.weekday = function () {
        if (this._is) {
            this._is = false;
            return (!this.is().sat() && !this.is().sun());
        }
        return false;
    };

    /** 
     * Sets the Time of the current Date instance. A string "6:15 pm" or config object {hour:18, minute:15} are accepted.
     * Example
    <pre><code>
    // Set time to 6:15pm with a String
    Date.today().at("6:15pm");

    // Set time to 6:15pm with a config object
    Date.today().at({hour:18, minute:15});
    </code></pre>
     *  
     * @return {Date}    date
     */
    $P.at = function (time) {
        return (typeof time === "string") ? $D.parse(this.toString("d") + " " + time) : this.set(time);
    };

    /** 
     * Creates a new Date() and adds this (Number) to the date based on the preceding date element function (eg. second|minute|hour|day|month|year).
     * Example
    <pre><code>
    // Undeclared Numbers must be wrapped with parentheses. Requirment of JavaScript.
    (3).days().fromNow();
    (6).months().fromNow();

    // Declared Number variables do not require parentheses. 
    var n = 6;
    n.months().fromNow();
    </code></pre>
     *  
     * @return {Date}    A new Date instance
     */
    $N.fromNow = $N.after = function (date) {
        var c = {};
        c[this._dateElement] = this;
        return ((!date) ? new Date() : date.clone()).add(c);
    };

    /** 
     * Creates a new Date() and subtract this (Number) from the date based on the preceding date element function (eg. second|minute|hour|day|month|year).
     * Example
    <pre><code>
    // Undeclared Numbers must be wrapped with parentheses. Requirment of JavaScript.
    (3).days().ago();
    (6).months().ago();

    // Declared Number variables do not require parentheses. 
    var n = 6;
    n.months().ago();
    </code></pre>
     *  
     * @return {Date}    A new Date instance
     */
    $N.ago = $N.before = function (date) {
        var c = {};
        c[this._dateElement] = this * -1;
        return ((!date) ? new Date() : date.clone()).add(c);
    };

    // Do NOT modify the following string tokens. These tokens are used to build dynamic functions.
    // All culture-specific strings can be found in the CultureInfo files. See /trunk/src/globalization/.
    var dx = ("sunday monday tuesday wednesday thursday friday saturday").split(/\s/),
        mx = ("january february march april may june july august september october november december").split(/\s/),
        px = ("Millisecond Second Minute Hour Day Week Month Year").split(/\s/),
        pxf = ("Milliseconds Seconds Minutes Hours Date Week Month FullYear").split(/\s/),
		nth = ("final first second third fourth fifth").split(/\s/),
        de;

    /** 
      * Returns an object literal of all the date parts.
      * Example
     <pre><code>
     var o = new Date().toObject();
     
     // { year: 2008, month: 4, week: 20, day: 13, hour: 18, minute: 9, second: 32, millisecond: 812 }
     
     // The object properties can be referenced directly from the object.
     
     alert(o.day);  // alerts "13"
     alert(o.year); // alerts "2008"
     </code></pre>
      *  
      * @return {Date}    An object literal representing the original date object.
      */
    $P.toObject = function () {
        var o = {};
        for (var i = 0; i < px.length; i++) {
            o[px[i].toLowerCase()] = this["get" + pxf[i]]();
        }
        return o;
    };

    /** 
      * Returns a date created from an object literal. Ignores the .week property if set in the config. 
      * Example
     <pre><code>
     var o = new Date().toObject();
     
     return Date.fromObject(o); // will return the same date. 
 
     var o2 = {month: 1, day: 20, hour: 18}; // birthday party!
     Date.fromObject(o2);
     </code></pre>
      *  
      * @return {Date}    An object literal representing the original date object.
      */
    $D.fromObject = function (config) {
        config.week = null;
        return Date.today().set(config);
    };

    // Create day name functions and abbreviated day name functions (eg. monday(), friday(), fri()).
    var df = function (n) {
        return function () {
            if (this._is) {
                this._is = false;
                return this.getDay() == n;
            }
            if (this._nth !== null) {
                // If the .second() function was called earlier, remove the _orient 
                // from the date, and then continue.
                // This is required because 'second' can be used in two different context.
                // 
                // Example
                //
                //   Date.today().add(1).second();
                //   Date.march().second().monday();
                // 
                // Things get crazy with the following...
                //   Date.march().add(1).second().second().monday(); // but it works!!
                //  
                if (this._isSecond) {
                    this.addSeconds(this._orient * -1);
                }
                // make sure we reset _isSecond
                this._isSecond = false;

                var ntemp = this._nth;
                this._nth = null;
                var temp = this.clone().moveToLastDayOfMonth();
                this.moveToNthOccurrence(n, ntemp);
                if (this > temp) {
                    throw new RangeError($D.getDayName(n) + " does not occur " + ntemp + " times in the month of " + $D.getMonthName(temp.getMonth()) + " " + temp.getFullYear() + ".");
                }
                return this;
            }
            return this.moveToDayOfWeek(n, this._orient);
        };
    };

    var sdf = function (n) {
        return function () {
            var t = $D.today(), shift = n - t.getDay();
            if (n === 0 && Date.CultureInfo.firstDayOfWeek === 1 && t.getDay() !== 0) {
                shift = shift + 7;
            }
            return t.addDays(shift);
        };
    };

    for (var i = 0; i < dx.length; i++) {
        // Create constant static Day Name variables. Example: Date.MONDAY or Date.MON
        $D[dx[i].toUpperCase()] = $D[dx[i].toUpperCase().substring(0, 3)] = i;

        // Create Day Name functions. Example: Date.monday() or Date.mon()
        $D[dx[i]] = $D[dx[i].substring(0, 3)] = sdf(i);

        // Create Day Name instance functions. Example: Date.today().next().monday()
        $P[dx[i]] = $P[dx[i].substring(0, 3)] = df(i);
    }

    // Create month name functions and abbreviated month name functions (eg. january(), march(), mar()).
    var mf = function (n) {
        return function () {
            if (this._is) {
                this._is = false;
                return this.getMonth() === n;
            }
            return this.moveToMonth(n, this._orient);
        };
    };

    var smf = function (n) {
        return function () {
            return $D.today().set({ month: n, day: 1 });
        };
    };

    for (var j = 0; j < mx.length; j++) {
        // Create constant static Month Name variables. Example: Date.MARCH or Date.MAR
        $D[mx[j].toUpperCase()] = $D[mx[j].toUpperCase().substring(0, 3)] = j;

        // Create Month Name functions. Example: Date.march() or Date.mar()
        $D[mx[j]] = $D[mx[j].substring(0, 3)] = smf(j);

        // Create Month Name instance functions. Example: Date.today().next().march()
        $P[mx[j]] = $P[mx[j].substring(0, 3)] = mf(j);
    }

    // Create date element functions and plural date element functions used with Date (eg. day(), days(), months()).
    var ef = function (j) {
        return function () {
            // if the .second() function was called earlier, the _orient 
            // has alread been added. Just return this and reset _isSecond.
            if (this._isSecond) {
                this._isSecond = false;
                return this;
            }

            if (this._same) {
                this._same = this._is = false;
                var o1 = this.toObject(),
                    o2 = (arguments[0] || new Date()).toObject(),
                    v = "",
                    k = j.toLowerCase();

                for (var m = (px.length - 1) ; m > -1; m--) {
                    v = px[m].toLowerCase();
                    if (o1[v] != o2[v]) {
                        return false;
                    }
                    if (k == v) {
                        break;
                    }
                }
                return true;
            }

            if (j.substring(j.length - 1) != "s") {
                j += "s";
            }
            return this["add" + j](this._orient);
        };
    };


    var nf = function (n) {
        return function () {
            this._dateElement = n;
            return this;
        };
    };

    for (var k = 0; k < px.length; k++) {
        de = px[k].toLowerCase();

        // Create date element functions and plural date element functions used with Date (eg. day(), days(), months()).
        $P[de] = $P[de + "s"] = ef(px[k]);

        // Create date element functions and plural date element functions used with Number (eg. day(), days(), months()).
        $N[de] = $N[de + "s"] = nf(de);
    }

    $P._ss = ef("Second");

    var nthfn = function (n) {
        return function (dayOfWeek) {
            if (this._same) {
                return this._ss(arguments[0]);
            }
            if (dayOfWeek || dayOfWeek === 0) {
                return this.moveToNthOccurrence(dayOfWeek, n);
            }
            this._nth = n;

            // if the operator is 'second' add the _orient, then deal with it later...
            if (n === 2 && (dayOfWeek === undefined || dayOfWeek === null)) {
                this._isSecond = true;
                return this.addSeconds(this._orient);
            }
            return this;
        };
    };

    for (var l = 0; l < nth.length; l++) {
        $P[nth[l]] = (l === 0) ? nthfn(-1) : nthfn(l);
    }
}());

/**
 * @version: 1.0 Alpha-1
 * @author: Coolite Inc. http://www.coolite.com/
 * @date: 2008-04-13
 * @copyright: Copyright (c) 2006-2008, Coolite Inc. (http://www.coolite.com/). All rights reserved.
 * @license: Licensed under The MIT License. See license.txt and http://www.datejs.com/license/. 
 * @website: http://www.datejs.com/
 */

(function () {
    Date.Parsing = {
        Exception: function (s) {
            this.message = "Parse error at '" + s.substring(0, 10) + " ...'";
        }
    };

    var $P = Date.Parsing;
    var _ = $P.Operators = {
        //
        // Tokenizers
        //
        rtoken: function (r) { // regex token
            return function (s) {
                var mx = s.match(r);
                if (mx) {
                    return ([mx[0], s.substring(mx[0].length)]);
                } else {
                    throw new $P.Exception(s);
                }
            };
        },
        token: function (s) { // whitespace-eating token
            return function (s) {
                return _.rtoken(new RegExp("^\s*" + s + "\s*"))(s);
                // Removed .strip()
                // return _.rtoken(new RegExp("^\s*" + s + "\s*"))(s).strip();
            };
        },
        stoken: function (s) { // string token
            return _.rtoken(new RegExp("^" + s));
        },

        //
        // Atomic Operators
        // 

        until: function (p) {
            return function (s) {
                var qx = [], rx = null;
                while (s.length) {
                    try {
                        rx = p.call(this, s);
                    } catch (e) {
                        qx.push(rx[0]);
                        s = rx[1];
                        continue;
                    }
                    break;
                }
                return [qx, s];
            };
        },
        many: function (p) {
            return function (s) {
                var rx = [], r = null;
                while (s.length) {
                    try {
                        r = p.call(this, s);
                    } catch (e) {
                        return [rx, s];
                    }
                    rx.push(r[0]);
                    s = r[1];
                }
                return [rx, s];
            };
        },

        // generator operators -- see below
        optional: function (p) {
            return function (s) {
                var r = null;
                try {
                    r = p.call(this, s);
                } catch (e) {
                    return [null, s];
                }
                return [r[0], r[1]];
            };
        },
        not: function (p) {
            return function (s) {
                try {
                    p.call(this, s);
                } catch (e) {
                    return [null, s];
                }
                throw new $P.Exception(s);
            };
        },
        ignore: function (p) {
            return p ?
            function (s) {
                var r = null;
                r = p.call(this, s);
                return [null, r[1]];
            } : null;
        },
        product: function () {
            var px = arguments[0],
            qx = Array.prototype.slice.call(arguments, 1), rx = [];
            for (var i = 0 ; i < px.length ; i++) {
                rx.push(_.each(px[i], qx));
            }
            return rx;
        },
        cache: function (rule) {
            var cache = {}, r = null;
            return function (s) {
                try {
                    r = cache[s] = (cache[s] || rule.call(this, s));
                } catch (e) {
                    r = cache[s] = e;
                }
                if (r instanceof $P.Exception) {
                    throw r;
                } else {
                    return r;
                }
            };
        },

        // vector operators -- see below
        any: function () {
            var px = arguments;
            return function (s) {
                var r = null;
                for (var i = 0; i < px.length; i++) {
                    if (px[i] == null) {
                        continue;
                    }
                    try {
                        r = (px[i].call(this, s));
                    } catch (e) {
                        r = null;
                    }
                    if (r) {
                        return r;
                    }
                }
                throw new $P.Exception(s);
            };
        },
        each: function () {
            var px = arguments;
            return function (s) {
                var rx = [], r = null;
                for (var i = 0; i < px.length ; i++) {
                    if (px[i] == null) {
                        continue;
                    }
                    try {
                        r = (px[i].call(this, s));
                    } catch (e) {
                        throw new $P.Exception(s);
                    }
                    rx.push(r[0]);
                    s = r[1];
                }
                return [rx, s];
            };
        },
        all: function () {
            var px = arguments, _ = _;
            return _.each(_.optional(px));
        },

        // delimited operators
        sequence: function (px, d, c) {
            d = d || _.rtoken(/^\s*/);
            c = c || null;

            if (px.length == 1) {
                return px[0];
            }
            return function (s) {
                var r = null, q = null;
                var rx = [];
                for (var i = 0; i < px.length ; i++) {
                    try {
                        r = px[i].call(this, s);
                    } catch (e) {
                        break;
                    }
                    rx.push(r[0]);
                    try {
                        q = d.call(this, r[1]);
                    } catch (ex) {
                        q = null;
                        break;
                    }
                    s = q[1];
                }
                if (!r) {
                    throw new $P.Exception(s);
                }
                if (q) {
                    throw new $P.Exception(q[1]);
                }
                if (c) {
                    try {
                        r = c.call(this, r[1]);
                    } catch (ey) {
                        throw new $P.Exception(r[1]);
                    }
                }
                return [rx, (r ? r[1] : s)];
            };
        },

        //
        // Composite Operators
        //

        between: function (d1, p, d2) {
            d2 = d2 || d1;
            var _fn = _.each(_.ignore(d1), p, _.ignore(d2));
            return function (s) {
                var rx = _fn.call(this, s);
                return [[rx[0][0], r[0][2]], rx[1]];
            };
        },
        list: function (p, d, c) {
            d = d || _.rtoken(/^\s*/);
            c = c || null;
            return (p instanceof Array ?
                _.each(_.product(p.slice(0, -1), _.ignore(d)), p.slice(-1), _.ignore(c)) :
                _.each(_.many(_.each(p, _.ignore(d))), px, _.ignore(c)));
        },
        set: function (px, d, c) {
            d = d || _.rtoken(/^\s*/);
            c = c || null;
            return function (s) {
                // r is the current match, best the current 'best' match
                // which means it parsed the most amount of input
                var r = null, p = null, q = null, rx = null, best = [[], s], last = false;

                // go through the rules in the given set
                for (var i = 0; i < px.length ; i++) {

                    // last is a flag indicating whether this must be the last element
                    // if there is only 1 element, then it MUST be the last one
                    q = null;
                    p = null;
                    r = null;
                    last = (px.length == 1);

                    // first, we try simply to match the current pattern
                    // if not, try the next pattern
                    try {
                        r = px[i].call(this, s);
                    } catch (e) {
                        continue;
                    }

                    // since we are matching against a set of elements, the first
                    // thing to do is to add r[0] to matched elements
                    rx = [[r[0]], r[1]];

                    // if we matched and there is still input to parse and 
                    // we don't already know this is the last element,
                    // we're going to next check for the delimiter ...
                    // if there's none, or if there's no input left to parse
                    // than this must be the last element after all ...
                    if (r[1].length > 0 && !last) {
                        try {
                            q = d.call(this, r[1]);
                        } catch (ex) {
                            last = true;
                        }
                    } else {
                        last = true;
                    }

                    // if we parsed the delimiter and now there's no more input,
                    // that means we shouldn't have parsed the delimiter at all
                    // so don't update r and mark this as the last element ...
                    if (!last && q[1].length === 0) {
                        last = true;
                    }


                    // so, if this isn't the last element, we're going to see if
                    // we can get any more matches from the remaining (unmatched)
                    // elements ...
                    if (!last) {

                        // build a list of the remaining rules we can match against,
                        // i.e., all but the one we just matched against
                        var qx = [];
                        for (var j = 0; j < px.length ; j++) {
                            if (i != j) {
                                qx.push(px[j]);
                            }
                        }

                        // now invoke recursively set with the remaining input
                        // note that we don't include the closing delimiter ...
                        // we'll check for that ourselves at the end
                        p = _.set(qx, d).call(this, q[1]);

                        // if we got a non-empty set as a result ...
                        // (otw rx already contains everything we want to match)
                        if (p[0].length > 0) {
                            // update current result, which is stored in rx ...
                            // basically, pick up the remaining text from p[1]
                            // and concat the result from p[0] so that we don't
                            // get endless nesting ...
                            rx[0] = rx[0].concat(p[0]);
                            rx[1] = p[1];
                        }
                    }

                    // at this point, rx either contains the last matched element
                    // or the entire matched set that starts with this element.

                    // now we just check to see if this variation is better than
                    // our best so far, in terms of how much of the input is parsed
                    if (rx[1].length < best[1].length) {
                        best = rx;
                    }

                    // if we've parsed all the input, then we're finished
                    if (best[1].length === 0) {
                        break;
                    }
                }

                // so now we've either gone through all the patterns trying them
                // as the initial match; or we found one that parsed the entire
                // input string ...

                // if best has no matches, just return empty set ...
                if (best[0].length === 0) {
                    return best;
                }

                // if a closing delimiter is provided, then we have to check it also
                if (c) {
                    // we try this even if there is no remaining input because the pattern
                    // may well be optional or match empty input ...
                    try {
                        q = c.call(this, best[1]);
                    } catch (ey) {
                        throw new $P.Exception(best[1]);
                    }

                    // it parsed ... be sure to update the best match remaining input
                    best[1] = q[1];
                }

                // if we're here, either there was no closing delimiter or we parsed it
            	// so now we have the best match; just return it!
                // console.log(best);
                return best;
            };
        },
        forward: function (gr, fname) {
            return function (s) {
                return gr[fname].call(this, s);
            };
        },

        //
        // Translation Operators
        //
        replace: function (rule, repl) {
            return function (s) {
                var r = rule.call(this, s);
                return [repl, r[1]];
            };
        },
        process: function (rule, fn) {
            return function (s) {
                var r = rule.call(this, s);
                return [fn.call(this, r[0]), r[1]];
            };
        },
        min: function (min, rule) {
            return function (s) {
                var rx = rule.call(this, s);
                if (rx[0].length < min) {
                    throw new $P.Exception(s);
                }
                return rx;
            };
        }
    };


    // Generator Operators And Vector Operators

    // Generators are operators that have a signature of F(R) => R,
    // taking a given rule and returning another rule, such as 
    // ignore, which parses a given rule and throws away the result.

    // Vector operators are those that have a signature of F(R1,R2,...) => R,
    // take a list of rules and returning a new rule, such as each.

    // Generator operators are converted (via the following _generator
    // function) into functions that can also take a list or array of rules
    // and return an array of new rules as though the function had been
    // called on each rule in turn (which is what actually happens).

    // This allows generators to be used with vector operators more easily.
    // Example:
    // each(ignore(foo, bar)) instead of each(ignore(foo), ignore(bar))

    // This also turns generators into vector operators, which allows
    // constructs like:
    // not(cache(foo, bar))

    var _generator = function (op) {
        return function () {
            var args = null, rx = [];
            if (arguments.length > 1) {
                args = Array.prototype.slice.call(arguments);
            } else if (arguments[0] instanceof Array) {
                args = arguments[0];
            }
            if (args) {
                for (var i = 0, px = args.shift() ; i < px.length ; i++) {
                    args.unshift(px[i]);
                    rx.push(op.apply(null, args));
                    args.shift();
                    return rx;
                }
            } else {
                return op.apply(null, arguments);
            }
        };
    };

    var gx = "optional not ignore cache".split(/\s/);

    for (var i = 0 ; i < gx.length ; i++) {
        _[gx[i]] = _generator(_[gx[i]]);
    }

    var _vector = function (op) {
        return function () {
            if (arguments[0] instanceof Array) {
                return op.apply(null, arguments[0]);
            } else {
                return op.apply(null, arguments);
            }
        };
    };

    var vx = "each any all".split(/\s/);

    for (var j = 0 ; j < vx.length ; j++) {
        _[vx[j]] = _vector(_[vx[j]]);
    }

}());

(function () {
    var $D = Date, $P = $D.prototype, $C = $D.CultureInfo;

    var flattenAndCompact = function (ax) {
        var rx = [];
        for (var i = 0; i < ax.length; i++) {
            if (ax[i] instanceof Array) {
                rx = rx.concat(flattenAndCompact(ax[i]));
            } else {
                if (ax[i]) {
                    rx.push(ax[i]);
                }
            }
        }
        return rx;
    };

    $D.Grammar = {};

    $D.Translator = {
        hour: function (s) {
            return function () {
                this.hour = Number(s);
            };
        },
        minute: function (s) {
            return function () {
                this.minute = Number(s);
            };
        },
        second: function (s) {
            return function () {
                this.second = Number(s);
            };
        },
        meridian: function (s) {
            return function () {
                this.meridian = s.slice(0, 1).toLowerCase();
            };
        },
        timezone: function (s) {
            return function () {
                var n = s.replace(/[^\d\+\-]/g, "");
                if (n.length) {
                    this.timezoneOffset = Number(n);
                } else {
                    this.timezone = s.toLowerCase();
                }
            };
        },
        day: function (x) {
            var s = x[0];
            return function () {
                this.day = Number(s.match(/\d+/)[0]);
            };
        },
        month: function (s) {
            return function () {
                this.month = (s.length == 3) ? "jan feb mar apr may jun jul aug sep oct nov dec".indexOf(s) / 4 : Number(s) - 1;
            };
        },
        year: function (s) {
            return function () {
                var n = Number(s);
                this.year = ((s.length > 2) ? n :
                    (n + (((n + 2000) < Date.CultureInfo.twoDigitYearMax) ? 2000 : 1900)));
            };
        },
        rday: function (s) {
            return function () {
                switch (s) {
                    case "yesterday":
                        this.days = -1;
                        break;
                    case "tomorrow":
                        this.days = 1;
                        break;
                    case "today":
                        this.days = 0;
                        break;
                    case "now":
                        this.days = 0;
                        this.now = true;
                        break;
                }
            };
        },
        finishExact: function (x) {
            x = (x instanceof Array) ? x : [x];

            for (var i = 0 ; i < x.length ; i++) {
                if (x[i]) {
                    x[i].call(this);
                }
            }

            var now = new Date();

            if ((this.hour || this.minute) && (!this.month && !this.year && !this.day)) {
                this.day = now.getDate();
            }

            if (!this.year) {
                this.year = now.getFullYear();
            }

            if (!this.month && this.month !== 0) {
                this.month = now.getMonth();
            }

            if (!this.day) {
                this.day = 1;
            }

            if (!this.hour) {
                this.hour = 0;
            }

            if (!this.minute) {
                this.minute = 0;
            }

            if (!this.second) {
                this.second = 0;
            }

            if (this.meridian && this.hour) {
                if (this.meridian == "p" && this.hour < 12) {
                    this.hour = this.hour + 12;
                } else if (this.meridian == "a" && this.hour == 12) {
                    this.hour = 0;
                }
            }

            if (this.day > $D.getDaysInMonth(this.year, this.month)) {
                throw new RangeError(this.day + " is not a valid value for days.");
            }

            var r = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second);

            if (this.timezone) {
                r.set({ timezone: this.timezone });
            } else if (this.timezoneOffset) {
                r.set({ timezoneOffset: this.timezoneOffset });
            }

            return r;
        },
        finish: function (x) {
            x = (x instanceof Array) ? flattenAndCompact(x) : [x];

            if (x.length === 0) {
                return null;
            }

            for (var i = 0 ; i < x.length ; i++) {
                if (typeof x[i] == "function") {
                    x[i].call(this);
                }
            }

            var today = $D.today();

            if (this.now && !this.unit && !this.operator) {
                return new Date();
            } else if (this.now) {
                today = new Date();
            }

            var expression = !!(this.days && this.days !== null || this.orient || this.operator);

            var gap, mod, orient;
            orient = ((this.orient == "past" || this.operator == "subtract") ? -1 : 1);
            
            // Last day of month
            if (this.orient == "lastDayOf") {
                var lastDayOfDate = new Date(this.year || today.getFullYear(), this.month + 1, 0);

                if (lastDayOfDate.getDate()) {
                    if (!this.year && (lastDayOfDate.getMonth() < today.getMonth() || (lastDayOfDate.getMonth() == today.getMonth() && lastDayOfDate.getDate() < today.getDate())))
                        lastDayOfDate.addYears(1);

                    return lastDayOfDate;
                }
            }

            // First day of month
            if (this.orient == "firstDayOf") {
                var firstDayOfDate = new Date(this.year || today.getFullYear(), this.month, 1);

                if (firstDayOfDate.getDate()) {
                    if (!this.year && (firstDayOfDate.getMonth() < today.getMonth() || (firstDayOfDate.getMonth() == today.getMonth() && firstDayOfDate.getDate() < today.getDate())))
                        firstDayOfDate.addYears(1);

                    return firstDayOfDate;
                }
            }

            // console.log(this.value, this.unit);

            if (!this.now && "hour minute second".indexOf(this.unit) != -1) {
                today.setTimeToNow();
            }

            if (this.month || this.month === 0) {
                if ("year day hour minute second".indexOf(this.unit) != -1) {
                    this.value = this.month + 1;
                    this.month = null;
                    expression = true;
                }
            }

            if (!expression && this.weekday && !this.day && !this.days) {
                var temp = Date[this.weekday]();
                this.day = temp.getDate();
                if (!this.month) {
                    this.month = temp.getMonth();
                }
                this.year = temp.getFullYear();
            }

            if (expression && this.weekday && this.unit != "month") {
                this.unit = "day";
                gap = ($D.getDayNumberFromName(this.weekday) - today.getDay());
                mod = 7;
                this.days = gap ? ((gap + (orient * mod)) % mod) : (orient * mod);
            }

            if (this.month && this.unit == "day" && this.operator) {
                this.value = (this.month + 1);
                this.month = null;
            }

            if (this.value != null && this.month != null && this.year != null) {
                this.day = this.value * 1;
            }

            if (this.month && !this.day && this.value) {
                today.set({ day: this.value * 1 });
                if (!expression) {
                    this.day = this.value * 1;
                }
            }

            if (!this.month && this.value && this.unit == "month" && !this.now) {
                this.month = this.value;
                expression = true;
            }

            if (expression && (this.month || this.month === 0) && this.unit != "year") {
                this.unit = "month";
                gap = (this.month - today.getMonth());
                mod = 12;
                this.months = this.value;// gap ? ((gap + (orient * mod)) % mod) : (orient * mod);
                this.month = null;
            }

            if (!this.unit) {
                this.unit = "day";
            }

            if (!this.value && this.operator && this.operator !== null && this[this.unit + "s"] && this[this.unit + "s"] !== null) {
                this[this.unit + "s"] = this[this.unit + "s"] + ((this.operator == "add") ? 1 : -1) + (this.value || 0) * orient;
            } else if (this[this.unit + "s"] == null || this.operator != null) {
                if (!this.value) {
                    this.value = 1;
                }
                this[this.unit + "s"] = this.value * orient;
            }

            if (this.meridian && this.hour) {
                if (this.meridian == "p" && this.hour < 12) {
                    this.hour = this.hour + 12;
                } else if (this.meridian == "a" && this.hour == 12) {
                    this.hour = 0;
                }
            }

            if (this.weekday && !this.day && !this.days) {
                var temp = Date[this.weekday]();
                this.day = temp.getDate();
                if (temp.getMonth() !== today.getMonth()) {
                    this.month = temp.getMonth();
                }
            }

            if ((this.month || this.month === 0) && !this.day) {
                this.day = 1;
            }
            
            if (!this.orient && !this.operator && this.unit == "week" && this.value && !this.day && !this.month) {
                if (this.value)
                {
                    this.operator = "add";
                    expression = true;
                }
                //  return Date.today().setWeek(this.value);
            }
            
            /*
                Added Cases:
            */
            
            if ( this.month != undefined && this.unit == "week")
            {
                this.value = (this.month + 1);
                this[this.unit + "s"] = this.value;
                this.operator = "add";
                this.month = null;
                this.day = null;
                expression = true;
            }

            if (this.unit == "month" && this.day == 1 && this.value == 1)
            {
                this.operator = "add";
                this.value = this[this.unit + "s"] = (this.month + 1);
                this.day = this.month = null;
                expression = true;
            }

            /*
                End Additions
            */

            if (expression && this.timezone && this.day && this.days) {
                this.day = this.days;
            }

            //console.log(this);

            return (expression) ? today.add(this) : today.set(this);
        }
    };

    var _ = $D.Parsing.Operators, g = $D.Grammar, t = $D.Translator, _fn;

    g.datePartDelimiter = _.rtoken(/^([\s\-\.\,\/\x27]+)/);
    g.timePartDelimiter = _.stoken(":");
    g.whiteSpace = _.rtoken(/^\s*/);
    g.generalDelimiter = _.rtoken(/^(([\s\,]|at|@|on)+)/);

    var _C = {};
    g.ctoken = function (keys) {
        var fn = _C[keys];
        if (!fn) {
            var c = Date.CultureInfo.regexPatterns;
            var kx = keys.split(/\s+/), px = [];
            for (var i = 0; i < kx.length ; i++) {
                px.push(_.replace(_.rtoken(c[kx[i]]), kx[i]));
            }
            fn = _C[keys] = _.any.apply(null, px);
        }
        return fn;
    };
    g.ctoken2 = function (key) {
        return _.rtoken(Date.CultureInfo.regexPatterns[key]);
    };

    // hour, minute, second, meridian, timezone
    g.h = _.cache(_.process(_.rtoken(/^(0[0-9]|1[0-2]|[1-9])/), t.hour));
    g.hh = _.cache(_.process(_.rtoken(/^(0[0-9]|1[0-2])/), t.hour));
    g.H = _.cache(_.process(_.rtoken(/^([0-1][0-9]|2[0-3]|[0-9])/), t.hour));
    g.HH = _.cache(_.process(_.rtoken(/^([0-1][0-9]|2[0-3])/), t.hour));
    g.m = _.cache(_.process(_.rtoken(/^([0-5][0-9]|[0-9])/), t.minute));
    g.mm = _.cache(_.process(_.rtoken(/^[0-5][0-9]/), t.minute));
    g.s = _.cache(_.process(_.rtoken(/^([0-5][0-9]|[0-9])/), t.second));
    g.ss = _.cache(_.process(_.rtoken(/^[0-5][0-9]/), t.second));
    g.hms = _.cache(_.sequence([g.H, g.m, g.s], g.timePartDelimiter));

    // _.min(1, _.set([ g.H, g.m, g.s ], g._t));
    g.t = _.cache(_.process(g.ctoken2("shortMeridian"), t.meridian));
    g.tt = _.cache(_.process(g.ctoken2("longMeridian"), t.meridian));
    g.z = _.cache(_.process(_.rtoken(/^((\+|\-)\s*\d\d\d\d)|((\+|\-)\d\d\:?\d\d)/), t.timezone));
    g.zz = _.cache(_.process(_.rtoken(/^((\+|\-)\s*\d\d\d\d)|((\+|\-)\d\d\:?\d\d)/), t.timezone));

    g.zzz = _.cache(_.process(g.ctoken2("timezone"), t.timezone));
    g.timeSuffix = _.each(_.ignore(g.whiteSpace), _.set([g.tt, g.zzz]));
    g.time = _.each(_.optional(_.ignore(_.stoken("T"))), g.hms, g.timeSuffix);

    // days, months, years
    g.d = _.cache(_.process(_.each(_.rtoken(/^([0-2]\d|3[0-1]|\d)/),
        _.optional(g.ctoken2("ordinalSuffix"))), t.day));
    g.dd = _.cache(_.process(_.each(_.rtoken(/^([0-2]\d|3[0-1])/),
        _.optional(g.ctoken2("ordinalSuffix"))), t.day));
    g.ddd = g.dddd = _.cache(_.process(g.ctoken("sun mon tue wed thu fri sat"),
        function (s) {
            return function () {
                this.weekday = s;
            };
        }
    ));
    g.M = _.cache(_.process(_.rtoken(/^(1[0-2]|0\d|\d)/), t.month));
    g.MM = _.cache(_.process(_.rtoken(/^(1[0-2]|0\d)/), t.month));
    g.MMM = g.MMMM = _.cache(_.process(
        g.ctoken("jan feb mar apr may jun jul aug sep oct nov dec"), t.month));
    g.y = _.cache(_.process(_.rtoken(/^(\d\d?)/), t.year));
    g.yy = _.cache(_.process(_.rtoken(/^(\d\d)/), t.year));
    g.yyy = _.cache(_.process(_.rtoken(/^(\d\d?\d?\d?)/), t.year));
    g.yyyy = _.cache(_.process(_.rtoken(/^(\d\d\d\d)/), t.year));

    // rolling these up into general purpose rules
    _fn = function () {
        return _.each(_.any.apply(null, arguments), _.not(g.ctoken2("timeContext")));
    };

    g.day = _fn(g.d, g.dd);
    g.month = _fn(g.M, g.MMM);
    g.year = _fn(g.yyyy, g.yy);

    // relative date / time expressions
    g.orientation = _.process(g.ctoken("lastDayOf firstDayOf past future"),
        function (s) {
            return function () {
                this.orient = s;
            };
        }
    );
    g.operator = _.process(g.ctoken("add subtract"),
        function (s) {
            return function () {
                this.operator = s;
            };
        }
    );
    g.rday = _.process(g.ctoken("yesterday tomorrow today now"), t.rday);
    g.unit = _.process(g.ctoken("second minute hour day week month year"),
        function (s) {
            return function () {
                this.unit = s;
            };
        }
    );
    g.value = _.process(_.rtoken(/^\d\d?(st|nd|rd|th)?/),
        function (s) {
            return function () {
                this.value = s.replace(/\D/g, "");
            };
        }
    );
    g.expression = _.set([g.rday, g.operator, g.value, g.unit, g.orientation, g.ddd, g.MMM, g.yyyy]);

    // pre-loaded rules for different date part order preferences
    _fn = function () {
        return _.set(arguments, g.datePartDelimiter);
    };
    g.mdy = _fn(g.ddd, g.month, g.day, g.year);
    g.ymd = _fn(g.ddd, g.year, g.month, g.day);
    g.dmy = _fn(g.ddd, g.day, g.month, g.year);
    g.date = function (s) {
        return ((g[Date.CultureInfo.dateElementOrder] || g.mdy).call(this, s));
    };

    // parsing date format specifiers - ex: "h:m:s tt" 
    // this little guy will generate a custom parser based
    // on the format string, ex: g.format("h:m:s tt")
    g.format = _.process(_.many(
        _.any(
        // translate format specifiers into grammar rules
        _.process(
        _.rtoken(/^(dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|zz?z?)/),
        function (fmt) {
            if (g[fmt]) {
                return g[fmt];
            } else {
                throw $D.Parsing.Exception(fmt);
            }
        }
    ),
    // translate separator tokens into token rules
    _.process(
    _.rtoken(/^[^dMyhHmstz]+/), // all legal separators 
        function (s) {
            return _.ignore(_.stoken(s));
        }
    )
    )),
        // construct the parser ...
        function (rules) {
            return _.process(_.each.apply(null, rules), t.finishExact);
        }
    );

    var _F = {
        //"M/d/yyyy": function (s) { 
        //	var m = s.match(/^([0-2]\d|3[0-1]|\d)\/(1[0-2]|0\d|\d)\/(\d\d\d\d)/);
        //	if (m!=null) { 
        //		var r =  [ t.month.call(this,m[1]), t.day.call(this,m[2]), t.year.call(this,m[3]) ];
        //		r = t.finishExact.call(this,r);
        //		return [ r, "" ];
        //	} else {
        //		throw new Date.Parsing.Exception(s);
        //	}
        //}
        //"M/d/yyyy": function (s) { return [ new Date(Date._parse(s)), ""]; }
    };
    var _get = function (f) {
        return _F[f] = (_F[f] || g.format(f)[0]);
    };

    g.formats = function (fx) {
        if (fx instanceof Array) {
            var rx = [];
            for (var i = 0 ; i < fx.length ; i++) {
                rx.push(_get(fx[i]));
            }
            return _.any.apply(null, rx);
        } else {
            return _get(fx);
        }
    };

    // check for these formats first
    g._formats = g.formats([]);
    //    "\"yyyy-MM-ddTHH:mm:ssZ\"",
    //    "yyyy-MM-ddTHH:mm:ssZ",
    //    "yyyy-MM-ddTHH:mm:ssz",
    //    "yyyy-MM-ddTHH:mm:ss",
    //    "yyyy-MM-ddTHH:mmZ",
    //    "yyyy-MM-ddTHH:mmz",
    //    "yyyy-MM-ddTHH:mm",
    //    "ddd, MMM dd, yyyy H:mm:ss tt",
    //    "ddd MMM d yyyy HH:mm:ss zzz",
    //    "MMddyyyy",
    //    "ddMMyyyy",
    //    "Mddyyyy",
    //    "ddMyyyy",
    //    "Mdyyyy",
    //    "dMyyyy",
    //    "yyyy",
    //    "Mdyy",
    //    "dMyy",
    //    "d"
    //]);

    // starting rule for general purpose grammar
    g._start = _.process(_.set([g.date, g.time, g.expression],
        g.generalDelimiter, g.whiteSpace), t.finish);

    // real starting rule: tries selected formats first, 
    // then general purpose rule
    g.start = function (s) {
        try {
            var r = g._formats.call({}, s);
            if (r[1].length === 0) {
                return r;
            }
        } catch (e) { }
        return g._start.call({}, s);
    };

    $D._parse = $D.parse;

    /**
     * Converts the specified string value into its JavaScript Date equivalent using CultureInfo specific format information.
     * 
     * Example
    <pre><code>
    ///////////
    // Dates //
    ///////////

    // 15-Oct-2004
    var d1 = Date.parse("10/15/2004");

    // 15-Oct-2004
    var d1 = Date.parse("15-Oct-2004");

    // 15-Oct-2004
    var d1 = Date.parse("2004.10.15");

    //Fri Oct 15, 2004
    var d1 = Date.parse("Fri Oct 15, 2004");

    ///////////
    // Times //
    ///////////

    // Today at 10 PM.
    var d1 = Date.parse("10 PM");

    // Today at 10:30 PM.
    var d1 = Date.parse("10:30 P.M.");

    // Today at 6 AM.
    var d1 = Date.parse("06am");

    /////////////////////
    // Dates and Times //
    /////////////////////

    // 8-July-2004 @ 10:30 PM
    var d1 = Date.parse("July 8th, 2004, 10:30 PM");

    // 1-July-2004 @ 10:30 PM
    var d1 = Date.parse("2004-07-01T22:30:00");

    ////////////////////
    // Relative Dates //
    ////////////////////

    // Returns today's date. The string "today" is culture specific.
    var d1 = Date.parse("today");

    // Returns yesterday's date. The string "yesterday" is culture specific.
    var d1 = Date.parse("yesterday");

    // Returns the date of the next thursday.
    var d1 = Date.parse("Next thursday");

    // Returns the date of the most previous monday.
    var d1 = Date.parse("last monday");

    // Returns today's day + one year.
    var d1 = Date.parse("next year");

    ///////////////
    // Date Math //
    ///////////////

    // Today + 2 days
    var d1 = Date.parse("t+2");

    // Today + 2 days
    var d1 = Date.parse("today + 2 days");

    // Today + 3 months
    var d1 = Date.parse("t+3m");

    // Today - 1 year
    var d1 = Date.parse("today - 1 year");

    // Today - 1 year
    var d1 = Date.parse("t-1y"); 


    /////////////////////////////
    // Partial Dates and Times //
    /////////////////////////////

    // July 15th of this year.
    var d1 = Date.parse("July 15");

    // 15th day of current day and year.
    var d1 = Date.parse("15");

    // July 1st of current year at 10pm.
    var d1 = Date.parse("7/1 10pm");
    </code></pre>
     *
     * @param {String}   The string value to convert into a Date object [Required]
     * @return {Date}    A Date object or null if the string cannot be converted into a Date.
     */
    $D.parse = function (s) {
        var r = null;
        if (!s) {
            return null;
        }
        if (s instanceof Date) {
            return s;
        }
        try {
            r = $D.Grammar.start.call({}, s.replace(/^\s*(\S*(\s+\S+)*)\s*$/, "$1"));
        } catch (e) {
            return null;
        }
        return ((r[1].length === 0) ? r[0] : null);
    };

    $D.getParseFunction = function (fx) {
        var fn = $D.Grammar.formats(fx);
        return function (s) {
            var r = null;
            try {
                r = fn.call({}, s);
            } catch (e) {
                return null;
            }
            return ((r[1].length === 0) ? r[0] : null);
        };
    };

    /**
     * Converts the specified string value into its JavaScript Date equivalent using the specified format {String} or formats {Array} and the CultureInfo specific format information.
     * The format of the string value must match one of the supplied formats exactly.
     * 
     * Example
    <pre><code>
    // 15-Oct-2004
    var d1 = Date.parseExact("10/15/2004", "M/d/yyyy");

    // 15-Oct-2004
    var d1 = Date.parse("15-Oct-2004", "M-ddd-yyyy");

    // 15-Oct-2004
    var d1 = Date.parse("2004.10.15", "yyyy.MM.dd");

    // Multiple formats
    var d1 = Date.parseExact("10/15/2004", ["M/d/yyyy", "MMMM d, yyyy"]);
    </code></pre>
     *
     * @param {String}   The string value to convert into a Date object [Required].
     * @param {Object}   The expected format {String} or an array of expected formats {Array} of the date string [Required].
     * @return {Date}    A Date object or null if the string cannot be converted into a Date.
     */
    $D.parseExact = function (s, fx) {
        return $D.getParseFunction(fx)(s);
    };
}());


/**
 * @version: 1.0 Alpha-1
 * @author: Coolite Inc. http://www.coolite.com/
 * @date: 2008-04-13
 * @copyright: Copyright (c) 2006-2008, Coolite Inc. (http://www.coolite.com/). All rights reserved.
 * @license: Licensed under The MIT License. See license.txt and http://www.datejs.com/license/.
 * @website: http://www.datejs.com/
 */

/*
 * TimeSpan(milliseconds);
 * TimeSpan(days, hours, minutes, seconds);
 * TimeSpan(days, hours, minutes, seconds, milliseconds);
 */
var TimeSpan = function (days, hours, minutes, seconds, milliseconds) {
  var attrs = "days hours minutes seconds milliseconds".split(/\s+/);

  var gFn = function (attr) {
    return function () {
      return this[attr];
    };
  };

  var sFn = function (attr) {
    return function (val) {
      this[attr] = val;
      return this;
    };
  };

  for (var i = 0; i < attrs.length ; i++) {
    var $a = attrs[i], $b = $a.slice(0, 1).toUpperCase() + $a.slice(1);
    TimeSpan.prototype[$a] = 0;
    TimeSpan.prototype["get" + $b] = gFn($a);
    TimeSpan.prototype["set" + $b] = sFn($a);
  }

  if (arguments.length == 4) {
    this.setDays(days);
    this.setHours(hours);
    this.setMinutes(minutes);
    this.setSeconds(seconds);
  } else if (arguments.length == 5) {
    this.setDays(days);
    this.setHours(hours);
    this.setMinutes(minutes);
    this.setSeconds(seconds);
    this.setMilliseconds(milliseconds);
  } else if (arguments.length == 1 && typeof days == "number") {
    var orient = (days < 0) ? -1 : +1;
    this.setMilliseconds(Math.abs(days));

    this.setDays(Math.floor(this.getMilliseconds() / 86400000) * orient);
    this.setMilliseconds(this.getMilliseconds() % 86400000);

    this.setHours(Math.floor(this.getMilliseconds() / 3600000) * orient);
    this.setMilliseconds(this.getMilliseconds() % 3600000);

    this.setMinutes(Math.floor(this.getMilliseconds() / 60000) * orient);
    this.setMilliseconds(this.getMilliseconds() % 60000);

    this.setSeconds(Math.floor(this.getMilliseconds() / 1000) * orient);
    this.setMilliseconds(this.getMilliseconds() % 1000);

    this.setMilliseconds(this.getMilliseconds() * orient);
  }

  this.getTotalMilliseconds = function () {
    return (this.getDays() * 86400000) + (this.getHours() * 3600000) + (this.getMinutes() * 60000) + (this.getSeconds() * 1000);
  };

  this.compareTo = function (time) {
    var t1 = new Date(1970, 1, 1, this.getHours(), this.getMinutes(), this.getSeconds()), t2;
    if (time === null) {
      t2 = new Date(1970, 1, 1, 0, 0, 0);
    }
    else {
      t2 = new Date(1970, 1, 1, time.getHours(), time.getMinutes(), time.getSeconds());
    }
    return (t1 < t2) ? -1 : (t1 > t2) ? 1 : 0;
  };

  this.equals = function (time) {
    return (this.compareTo(time) === 0);
  };

  this.add = function (time) {
    return (time === null) ? this : this.addSeconds(time.getTotalMilliseconds() / 1000);
  };

  this.subtract = function (time) {
    return (time === null) ? this : this.addSeconds(-time.getTotalMilliseconds() / 1000);
  };

  this.addDays = function (n) {
    return new TimeSpan(this.getTotalMilliseconds() + (n * 86400000));
  };

  this.addHours = function (n) {
    return new TimeSpan(this.getTotalMilliseconds() + (n * 3600000));
  };

  this.addMinutes = function (n) {
    return new TimeSpan(this.getTotalMilliseconds() + (n * 60000));
  };

  this.addSeconds = function (n) {
    return new TimeSpan(this.getTotalMilliseconds() + (n * 1000));
  };

  this.addMilliseconds = function (n) {
    return new TimeSpan(this.getTotalMilliseconds() + n);
  };

  this.get12HourHour = function () {
    return (this.getHours() > 12) ? this.getHours() - 12 : (this.getHours() === 0) ? 12 : this.getHours();
  };

  this.getDesignator = function () {
    return (this.getHours() < 12) ? Date.CultureInfo.amDesignator : Date.CultureInfo.pmDesignator;
  };

  this.toString = function (format) {
    this._toString = function () {
      if (this.getDays() !== null && this.getDays() > 0) {
        return this.getDays() + "." + this.getHours() + ":" + this.p(this.getMinutes()) + ":" + this.p(this.getSeconds());
      }
      else {
        return this.getHours() + ":" + this.p(this.getMinutes()) + ":" + this.p(this.getSeconds());
      }
    };

    this.p = function (s) {
      return (s.toString().length < 2) ? "0" + s : s;
    };

    var me = this;

    return format ? format.replace(/dd?|HH?|hh?|mm?|ss?|tt?/g,
      function (format) {
        switch (format) {
          case "d":
            return me.getDays();
          case "dd":
            return me.p(me.getDays());
          case "H":
            return me.getHours();
          case "HH":
            return me.p(me.getHours());
          case "h":
            return me.get12HourHour();
          case "hh":
            return me.p(me.get12HourHour());
          case "m":
            return me.getMinutes();
          case "mm":
            return me.p(me.getMinutes());
          case "s":
            return me.getSeconds();
          case "ss":
            return me.p(me.getSeconds());
          case "t":
            return ((me.getHours() < 12) ? Date.CultureInfo.amDesignator : Date.CultureInfo.pmDesignator).substring(0, 1);
          case "tt":
            return (me.getHours() < 12) ? Date.CultureInfo.amDesignator : Date.CultureInfo.pmDesignator;
        }
      }
    ) : this._toString();
  };
  return this;
};

/**
 * Gets the time of day for this date instances.
 * @return {TimeSpan} TimeSpan
 */
Date.prototype.getTimeOfDay = function () {
  return new TimeSpan(0, this.getHours(), this.getMinutes(), this.getSeconds(), this.getMilliseconds());
};

/*
 * TimePeriod(startDate, endDate);
 * TimePeriod(years, months, days, hours, minutes, seconds, milliseconds);
 */
var TimePeriod = function (years, months, days, hours, minutes, seconds, milliseconds) {
  var attrs = "years months days hours minutes seconds milliseconds".split(/\s+/);

  var gFn = function (attr) {
    return function () {
      return this[attr];
    };
  };

  var sFn = function (attr) {
    return function (val) {
      this[attr] = val;
      return this;
    };
  };

  for (var i = 0; i < attrs.length ; i++) {
    var $a = attrs[i], $b = $a.slice(0, 1).toUpperCase() + $a.slice(1);
    TimePeriod.prototype[$a] = 0;
    TimePeriod.prototype["get" + $b] = gFn($a);
    TimePeriod.prototype["set" + $b] = sFn($a);
  }

  if (arguments.length == 7) {
    this.years = years;
    this.months = months;
    this.setDays(days);
    this.setHours(hours);
    this.setMinutes(minutes);
    this.setSeconds(seconds);
    this.setMilliseconds(milliseconds);
  } else if (arguments.length == 2 && arguments[0] instanceof Date && arguments[1] instanceof Date) {
    // startDate and endDate as arguments

    var d1 = years.clone();
    var d2 = months.clone();

    var temp = d1.clone();
    var orient = (d1 > d2) ? -1 : +1;

    this.years = d2.getFullYear() - d1.getFullYear();
    temp.addYears(this.years);

    if (orient == +1) {
      if (temp > d2) {
        if (this.years !== 0) {
          this.years--;
        }
      }
    } else {
      if (temp < d2) {
        if (this.years !== 0) {
          this.years++;
        }
      }
    }

    d1.addYears(this.years);

    if (orient == +1) {
      while (d1 < d2 && d1.clone().addDays(Date.getDaysInMonth(d1.getYear(), d1.getMonth()) ) < d2) {
        d1.addMonths(1);
        this.months++;
      }
    }
    else {
      while (d1 > d2 && d1.clone().addDays(-d1.getDaysInMonth()) > d2) {
        d1.addMonths(-1);
        this.months--;
      }
    }

    var diff = d2 - d1;

    if (diff !== 0) {
      var ts = new TimeSpan(diff);
      this.setDays(ts.getDays());
      this.setHours(ts.getHours());
      this.setMinutes(ts.getMinutes());
      this.setSeconds(ts.getSeconds());
      this.setMilliseconds(ts.getMilliseconds());
    }
  }
  return this;
};
/* ==================================================================
	AngularJS Datatype Editor

	Common code. Sets up the module for use in your app

	Usage:
		var MyApp = angular.module('MyApp', ['ADE']);

------------------------------------------------------------------*/

'use strict'; //http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/

angular.module('ADE', []).factory('ADE', ['$rootScope', function($rootScope) {

	// Common
	var miniBtnClasses = 'btn btn-mini btn-primary';
	var popupClass = 'ade-popup';
	var icons = ['heart', 'film', 'music', 'camera', 'shopping-cart', 'flag', 'picture', 'gift',
		  'calendar', 'time', 'thumbs-up', 'thumbs-down', 'hand-right', 'hand-left', 'info-sign', 'question-sign',
		  'exclamation-sign', 'trophy', 'pushpin', 'warning-sign', 'leaf', 'tint', 'coffee', 'magnet', 'envelope',
		  'inbox', 'bookmark', 'file', 'bell', 'asterisk', 'globe', 'plane', 'road', 'lock', 'book', 'wrench', 'home',
		  'briefcase', 'map-marker', 'eye-open', 'medkit', 'lightbulb', 'food', 'laptop', 'circle', 'money', 'bullhorn', 'legal', 'facebook','twitter'];

	//A flag that controls if certain ADE directives can accept keyboard input.
	//Causes display problems on iOS where there is no keyboard
	//Override in your contoller if you want
	var keyboardEdit = true; 
	var blurTimeout = false; //a timeout that allows external factors to cancel a blur event

	function hidePopup(elm) {
		var elPopup = (elm) ? elm.next('.' + popupClass) : angular.element('.' + popupClass);
		if (elPopup.length && elPopup.hasClass('open')) {
			elPopup.removeClass('open').remove();
		}
	}

	//=========================================================================================
	//broadcasts the message that we are starting editing
	function begin(id) {
		if(angular.isObject(id)) id = id.id;
		if (id) {
			$rootScope.$broadcast('ADE-start', id);
		}
	}

	//=========================================================================================
	//broadcasts the message that we are done editing
	//exit: 1=tab, -1=shift+tab, 2=return, -2=shift+return, 3=esc, 0=other
	function done(id, oldValue, value, exit) {
		if(angular.isObject(id)) id = id.id;
		if (id) {
			setTimeout(function() { //This is to give the model a chance to update before the notificaiton goes out
				$rootScope.$apply(function() { 
					$rootScope.$broadcast('ADE-finish', {'id': id, 'oldVal': oldValue, 'newVal': value, 'exit': exit });
				});
			});
		}
	}

	//=========================================================================================
	//registers a blur event on the input so we can know when we clicked outside
	//sends 0 to the callback to indicate that the blur was not caused by a keyboard event
	function setupBlur(input, callback, scope, skipTouch) {
		input.on('blur.ADE', function() {
			if(blurTimeout) clearTimeout(blurTimeout);
			blurTimeout = window.setTimeout(function() {
				blurTimeout = false;
				scope.$apply(function() { callback(0); });
			},100);
		});

		if(!skipTouch) setupTouchBlur(input);
	}

	//=========================================================================================
	// enables blur to work on touch devices by listing for any touch and bluring
	function setupTouchBlur(input) {
		if('ontouchend' in window) {
			$(document).on('touchend.ADE', function(e) {
				var target = $(e.target);
			
				var didTouchInPopup = target.parents('.'+popupClass).length>0 || target.hasClass(popupClass);
				var didTouchInTag = target.parents('.ade-tag-input').length>0;	
				var didTouchInList = target.parents('.ade-list-input').length>0;
				var didTouchIcon = target.hasClass(miniBtnClasses);
				var didTouchInput = target.hasClass('ade-input');
				var didTouchInDate = target.parents('.ade-date-popup').length>0;

				//ignore taps on ADE elements
				if(!didTouchIcon && !didTouchInPopup && !didTouchInTag && !didTouchInList && !didTouchInput && !didTouchInDate) {
					if(input) input.blur(); //it has to be in a timeout to allow other events to fire first
				}
			});
		}
	}

	function teardownBlur(input) {
		if(input) input.off('blur.ADE');
		$(document).off('touchend.ADE');
	}

	function cancelBlur() {
		if(blurTimeout) {
			clearTimeout(blurTimeout);
			blurTimeout = false;
		}
	}

	//=========================================================================================
	//registers the keyboard events on the input so we know how we left edit mode
	//sends an integer to the callback to indicate how we exited edit mode
	// 1 = tab, -1 = shift+tab, 2=return, -2=shift+return, 3=esc
	var bound = false; //There may be a better way to prevent the current event from finishing when I have unbound the event handler, but I couldnt find it
	function setupKeys(input, callback, ignoreReturn, scope) {
		bound = true;
		input.on('keydown.ADE', function(e) {
			if (e.keyCode == 9) { //tab
				e.preventDefault();
				e.stopPropagation();
				var exit = e.shiftKey ? -1 : 1;
				scope.$apply(function() { callback(exit); });
			} else if (e.keyCode == 27) { //esc
				e.preventDefault();
				e.stopPropagation();
				scope.$apply(function() { callback(3); });
			} else if (e.keyCode == 13 && ignoreReturn !== true) { //return // && bound
				e.preventDefault();
				e.stopPropagation();
				var exit = e.shiftKey ? -2 : 2;
				scope.$apply(function() { callback(exit); });
			}

		});
	}

	function teardownKeys(input) {
		if(input) {
			input.off('keydown.ADE');
			input.off('keypress.ADE');
		}
		//bound = false; //tells the key event listener to stop processing the current event
							//this seems to be necessary since stopPropigation wasn't working.
	}


	//=========================================================================================
	// Watch for scrolling and resizing to reposition our popups
	function setupScrollEvents(element,callback) {
		var sp = scrollParent(element);

		//when we scroll, should try to reposition because it may
		//go off the bottom/top and we may want to flip it
		//TODO; If it goes off the screen, should we dismiss it?
		$(sp).on('scroll.ADE',callback);

		//when the window resizes, we may need to reposition the popup
		$(window).on('resize.ADE',callback); 
	}

	function teardownScrollEvents(element) {
		var sp = scrollParent(element);
		$(sp).off('scroll.ADE');
		$(window).off('resize.ADE');
	}

	//place the popup in the proper place on the screen
	function place(id,element, extraV, extraH) {
		var popup = $(id);
		if(popup.length==0) return; //doesn't exist. oops
		
		var sp = scrollParent(element);

		if(!extraV) extraV = 2;
		if(!extraH) extraH = 7;

		var windowH = $(window).height();
		var windowW = $(window).width();
		var scrollV = $(sp).scrollTop();
		var scrollH = $(sp).scrollLeft();
		var elPosition = element.position(); //offset relative to document
		var elOffset = element.offset(); //offset relative to positioned parent
		var posLeft = Math.round(elPosition.left) - extraH;  // extraH = custom offset
		var posTop = Math.round(elPosition.top) + element.height() + extraV;
		var popupH = popup.height();
		var popupW = popup.width();
		var pickerBottom =  elOffset.top+element.height() + 2 + popupH;
		var pickerRight = elOffset.left-7 + popupW;

		popup.removeClass("flip");
		popup.removeClass("rarrow");

		//flip it up top if it would be off the bottom of page			
		var posTopFlip = Math.round(elPosition.top) - popupH - 13;
		if (pickerBottom-scrollV > windowH && posTopFlip>0) {
			posTop = posTopFlip;
			popup.addClass("flip");
		}

		if(windowW<=480) {
			posLeft = scrollH+5;
			popup.css({ left: posLeft, top: posTop, width: windowW-30});
			// console.log(posLeft, windowW, scrollH);

		} else {
			//Move to the left if it would be off the right of page
			if (pickerRight-scrollH > windowW) {
				posLeft = posLeft - popupW + 30;
				if(posLeft<0) posLeft = 0;
				popup.addClass("rarrow");
			}

			// console.log("place",posLeft,posTop);
			popup.css({ left: posLeft, top: posTop});
		}
	}

	function scrollParent(elem) {
		//taken and modified from jquery UI project
		var includeHidden = false;
		var position = elem.css( "position" ),
			excludeStaticParent = position === "absolute",
			overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
			scrollParent = elem.parents().filter( function() {
				var parent = $( this );
				if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
					return false;
				}
				return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) + parent.css( "overflow-x" ) );
			}).eq( 0 );

		return position === "fixed" || !scrollParent.length ? $( elem[ 0 ].ownerDocument || document ) : scrollParent;
	 }

	//=========================================================================================
	//exports public functions to ADE directives
	return {
		hidePopup: hidePopup,
		begin: begin,
		done: done,
		setupBlur: setupBlur,
		setupTouchBlur: setupTouchBlur,
		teardownBlur: teardownBlur,
		cancelBlur: cancelBlur,
		setupKeys: setupKeys,
		teardownKeys: teardownKeys,
		icons: icons,
		popupClass: popupClass,
		miniBtnClasses: miniBtnClasses,
		keyboardEdit: keyboardEdit,
		place: place,
		setupScrollEvents: setupScrollEvents,
		teardownScrollEvents: teardownScrollEvents
	};
}]);

/* ==================================================================
	AngularJS Datatype Editor - Number
	A directive to edit a number in place.

	Used for percent, money, decimal, integer

	Usage:
	<div ade-number="money" ade-id="1234" ng-model="data"></div>

	Config:
	ade-url:
		Defaults to "integer" but you can set "money" or "percemt" or "decimal" or "flex" to make it a certain type of number
	ade-id:
		If this id is set, it will be used in messages broadcast to the app on state changes.
	ade-class:
		A custom class to give to the input
	ade-readonly:
		If you don't want the stars to be editable	
	ade-precision:
		for the "decimal" field type, this specifies the number of numbers after the decimal. default=2

	Messages:
		name: ADE-start
		data: id from config

		name: ADE-finish
		data: {id from config, old value, new value, exit value}

------------------------------------------------------------------*/

angular.module('ADE').directive('adeNumber', ['ADE', '$compile', '$filter', function(ADE, $compile, $filter) {
	return {
		require: '?ngModel', //optional dependency for ngModel
		restrict: 'A', //Attribute declaration eg: <div ade-number=""></div>

		scope: {
			adeNumber: "@",
			adeId: "@",
			adeClass: "@",
			adeReadonly: "@",
			adePrecision: "=",
			ngModel: "="
		},

		//The link step (after compile)
		link: function(scope, element, attrs) {
			var editing = false; //are we in edit mode or not
			var input = null; //a reference to the input DOM object
			var exit = 0; //0=click, 1=tab, -1= shift tab, 2=return, -2=shift return, 3=esc. controls if you exited the field so you can focus the next field if appropriate
			var readonly = false;
			var inputClass = "";
			var precision = 2;
			var stopObserving = null;
			var adeId = scope.adeId;

			if(scope.adeClass!==undefined) inputClass = scope.adeClass;
			if(scope.adeReadonly!==undefined && scope.adeReadonly=="1") readonly = true;
			if(scope.adePrecision!==undefined) precision = parseInt(scope.adePrecision);

			var makeHTML = function() {
				var html = "";
				var value = scope.ngModel;
				
				if(value!==undefined) {					
					switch (scope.adeNumber) {
						case 'money':
							html = $filter('money')(value);
							break;
						
						case 'percent':
							html = $filter('percent')(value);
							break;

						case 'decimal':
							html = $filter('decimal')(value,precision);
							break;

						case 'flex':
							html = $filter('flexnum')(value);
							break;

						case 'integer':
						default:
							html = $filter('integer')(value);
					} 
				}

				element.html(html);
			};

			//called once the edit is done, so we can save the new data	and remove edit mode
			var saveEdit = function(exited) {
				var oldValue = scope.ngModel;
				exit = exited;

				if(exited!=3) { //don't save value on esc
					var value = input.val();
					value = value.replace(/[^0-9.-]/g, '');
					value = parseFloat(value);
					if(isNaN(value)) value = '';
					scope.ngModel = value;
				}

				element.show();
				if(input) {
					input.off();
					input.remove();
				}
				editing=false;

				ADE.done(adeId,oldValue,scope.ngModel,exit);
			};
			
			var clickHandler = function() {
				if(editing) return;
				editing=true;
				exit = 0;

				adeId = scope.adeId;
				ADE.begin(adeId);

				var value = scope.ngModel;
				if(angular.isArray(value) && value.length>0) value = value[0];
				if(angular.isString(value)) value = parseFloat(value.replace(/[$]/g, ''));
				else if(!angular.isNumber(value)) value = '';
				value = (value || value===0) ? value : '';

				var type = "text";

				//We don't really need this, but its a nice touch for iOS to present the number keyboard
				//Its not a good idea to always use number input because some desktop browsers dont display it correctly, or enforce integers
				var iOS = ( navigator.userAgent.match(/(iPad|iPhone|iPod)/g) ? true : false );
				if(iOS) type="number";

				element.hide();
				$compile('<input type="'+type+'" class="ade-input '+inputClass+'" value="'+value+'" />')(scope).insertAfter(element);
				input = element.next('input');
				input.focus();
				
				//put cursor at end
				input[0].selectionStart = input[0].selectionEnd = input.val().length; 

				ADE.setupBlur(input,saveEdit,scope);
				ADE.setupKeys(input,saveEdit,false,scope);

				input.on('keypress.ADE', function(e) {
					var keyCode = (e.keyCode ? e.keyCode : e.which); //firefox doesn't register keyCode on keypress only on keyup and down
					var control = e.ctrlKey || e.altKey || e.metaKey;
					
					if ((keyCode >= 48 && keyCode <= 57) || keyCode==36 || keyCode==37 || keyCode==38 || keyCode==39 || keyCode==40 || keyCode==44 || keyCode==45 || keyCode==46 || keyCode==8 || keyCode==9 || keyCode==27 || keyCode==13 || control) { //0-9 and .,-%$
						;//allowed characters
					} else {
						e.preventDefault();
						e.stopPropagation();
					}
				});
			};

			//setup events
			if(!readonly) {
				element.on('click.ADE', function(e) {
					scope.$apply(function() {
						clickHandler(e);
					})
				});
			}

			 //A callback to observe for changes to the id and save edit
			//The model will still be connected, so it is safe, but don't want to cause problems
			var observeID = function(value) {
				 //this gets called even when the value hasn't changed, 
				 //so we need to check for changes ourselves
				 if(editing && adeId!==value) saveEdit(3);
			};

			//If ID changes during edit, something bad happened. No longer editing the right thing. Cancel
			stopObserving = attrs.$observe('adeId', observeID);

			scope.$on('$destroy', function() { //need to clean up the event watchers when the scope is destroyed
				if(element) {
					element.off('click.ADE');
					if(input) input.off('keypress.ADE');
				}

				if(stopObserving && stopObserving!=observeID) { //Angualar <=1.2 returns callback, not deregister fn
					stopObserving();
					stopObserving = null;
				} else {
					delete attrs.$$observers['adeId'];
				}
			});

			//need to watch the model for changes
			scope.$watch(function(scope) {
				return scope.ngModel;
			}, function () {
				makeHTML();
			});

		}
	};
}]);
/* ==================================================================
	AngularJS Datatype Editor - URL
	A directive to edit a url field in place. You can also specify that
	the url is an email address or phone number and it will customize
	the link for those purposes.

	Usage:
	<div ade-url='url' ade-id='1234' ade-class="myClass" ng-model="data"></div>

	Config:

	ade-url:
		Defaults to "url" but you can set "phone" or "email" to make it a certain type of url
	ade-id:
		If this id is set, it will be used in messages broadcast to the app on state changes.
	ade-class:
		A custom class to give to the input
	ade-readonly:
		If you don't want the url to be editable	

	Messages:
		name: ADE-start
		data: id from config

		name: ADE-finish
		data: {id from config, old value, new value, exit value}

------------------------------------------------------------------*/

angular.module('ADE').directive('adeUrl', ['ADE', '$compile', '$filter', function(ADE, $compile, $filter) {
	return {
		require: '?ngModel', //optional dependency for ngModel
		restrict: 'A', //Attribute declaration eg: <div ade-url=""></div>

		scope: {
			adeUrl: "@",
			adeId: "@",
			adeClass: "@",
			adeReadonly: "@",
			ngModel: "="
		},

		//The link step (after compile)
		link: function(scope, element, attrs) {
			var editing = false;
			var input = null;
			var invisibleInput = null;
			var exit = 0; //0=click, 1=tab, -1= shift tab, 2=return, -2=shift return, 3=esc. controls if you exited the field so you can focus the next field if appropriate
			var timeout = null;
			var readonly = false;
			var inputClass = "";
			var stopObserving = null;
			var adeId = scope.adeId;

			if(scope.adeClass!==undefined) inputClass = scope.adeClass;
			if(scope.adeReadonly!==undefined && scope.adeReadonly=="1") readonly = true;

			var makeHTML = function() {
				var html = "";
				var value = scope.ngModel;
				
				if(value!==undefined) {
					if(angular.isArray(value)) value = value[0];
					if(!angular.isString(value)) value = value.toString();
					
					switch (scope.adeUrl) {
						case 'email':
							html = $filter('email')(value);
							break;

						case 'phone':
							html = $filter('phone')(value);

							//this is because iOS (and others?) will detect a tel: link and take over
							//blocking our clicks from working
							if(('ontouchstart' in window) && html.indexOf('<a href="tel:')==0) {
								html = '<a href="call:'+html.substr(13);
							}
							break;

						case 'url':
						default:
							html = $filter('url')(value);
					} 
				}

				element.html(html);
			};

			//called once the edit is done, so we can save the new data and remove edit mode
			var saveEdit = function(exited) {
				var oldValue = scope.ngModel;
				exit = exited;

				if (exit !== 3) {
					//don't save value on esc
					if (input) {
						scope.ngModel = input.val();
					}
				}

				element.show();
				destroy();
				editing = false;

				ADE.done(adeId, oldValue, scope.ngModel, exit);
				ADE.teardownBlur(input);
				ADE.teardownKeys(input);
				if(invisibleInput) {
					invisibleInput.off('blur.ADE');
					ADE.teardownKeys(invisibleInput);
				}
			};

			//called to enter edit mode on a url. happens immediatly for non-urls or after a popup confirmation for urls
			var editLink = function() {
				if (timeout) window.clearTimeout(timeout); //cancels the delayed blur of the popup
				editing = true;
				exit = 0;

				adeId = scope.adeId;
				ADE.begin(adeId);

				if(!angular.isString(scope.ngModel)) scope.ngModel = scope.ngModel ? scope.ngModel.toString() : '';

				element.hide(); //hide the read only data
				ADE.hidePopup(element);
				$compile('<input type="text" class="ade-input ' + inputClass + '" value="' + scope.ngModel.replace(/"/g,'&quot;') + '" />')(scope).insertAfter(element);
				input = element.next('input');
				input.focus();

				//put cursor at end
				input[0].selectionStart = input[0].selectionEnd = input.val().length; 

				ADE.setupBlur(input, saveEdit, scope);
				ADE.setupKeys(input, saveEdit, false, scope);
			};

			//place the popup in the proper place on the screen
			var place = function() {
				ADE.place('.'+ADE.popupClass,element,15,-5);
			};

			//when a link is clicked
			//if editable and link, present popup with what action you want to take (follow, edit)
			//if editable and not link, enter edit mode
			//if not editable and link, follow link
			var clickHandler = function(e) {

				// if user is holding shift, control, or command, let the link work
   			if (e.ctrlKey || e.shiftKey || e.metaKey) return;

				if (editing) {
					e.preventDefault(); //these two lines prevent the click on the link from actually taking you there
					e.stopPropagation();
					return; //already editing
				}

				var popup = $('.'+ADE.popupClass);
				if(popup.length) {
					$(document).trigger('ADE_hidepops.ADE');
				}

				//generate html for the popup
				var linkString = scope.ngModel ? scope.ngModel.toString() : '';
				var isurl = false;

				var html = '';
				switch (scope.adeUrl) {
					case 'email':
						isurl = $filter('email')(scope.ngModel).match('mailto:');
						if (!linkString.match('mailto:')) linkString = 'mailto:' + linkString; //put an http if omitted so the link is clickable
						html = '<div class="' + ADE.popupClass + ' ade-links dropdown-menu open">' +
								'<a class="' + ADE.miniBtnClasses + '" href="' + linkString + '" ng-click="ADE.hidePopup();">Send Email</a>' +
								' or <a class="' + ADE.miniBtnClasses + ' ade-edit-link">Edit</a>' +
								'<div class="ade-hidden"><input class="invisinput" type="text" /></div>' +
								'</div>';
						break;
						
					case 'phone':
						isurl = $filter('phone')(scope.ngModel).match('tel:');
						if (!linkString.match('tel:')) linkString = 'tel:' + linkString; //put an http if omitted so the link is clickable
						html = '<div class="' + ADE.popupClass  + ' ade-links dropdown-menu open">' +
								'<a class="' + ADE.miniBtnClasses + '" href="' + linkString + '" ng-click="ADE.hidePopup();">Call Number</a>' +
								' or <a class="' + ADE.miniBtnClasses + ' ade-edit-link">Edit</a>' +
								'<div class="ade-hidden"><input class="invisinput" type="text" /></div>' +
								'</div>';
						break;

					case 'url':
					default:
						isurl = $filter('url')(scope.ngModel).match(/https?:/);
						if (!linkString.match(/https?:/)) linkString = 'http://' + linkString; //put an http if omitted so the link is clickable
						html = '<div class="' + ADE.popupClass  + ' ade-links dropdown-menu open">' +
								'<a class="' + ADE.miniBtnClasses + '" href="' + linkString + '" target="_blank" ng-click="ADE.hidePopup();">Follow Link</a>' +
								' or <a class="' + ADE.miniBtnClasses + ' ade-edit-link">Edit</a>' +
								'<div class="ade-hidden"><input class="invisinput" type="text" /></div>' +
								'</div>';
				}

				//if it matches as a URL, then make the popup
				if (scope.ngModel !== '' && isurl && !readonly) {
					e.preventDefault(); 
					e.stopPropagation();
					if (!element.next('.' + ADE.popupClass ).length) { //don't make a duplicate popup

						$compile(html)(scope).insertAfter(element);
						place();

						var editLinkNode = element.next('.ade-links').find('.ade-edit-link');
						editLinkNode.on('click.ADE', editLink);

						//There is an invisible input box that handles blur and keyboard events on the popup
						invisibleInput = element.next('.ade-links').find('.invisinput');
						if(ADE.keyboardEdit) invisibleInput.focus(); //focus the invisible input

						ADE.setupKeys(invisibleInput, saveEdit, false, scope);

						invisibleInput.on('blur.ADE', function(e) {
							ADE.teardownKeys(invisibleInput);
							invisibleInput.off('blur.ADE');
							ADE.teardownBlur();
							invisibleInput = null;
							//We delay the closure of the popup to give the internal buttons a chance to fire
							timeout = window.setTimeout(function() {
								if(editLinkNode) editLinkNode.off('click.ADE');
								ADE.hidePopup(element);
							},300);
						});

						ADE.setupTouchBlur(invisibleInput);
					}
				} else if(!readonly) { //the editing field is not a clickable link, so directly edit it
					e.preventDefault(); 
					e.stopPropagation();
					editLink();
				}

				ADE.setupScrollEvents(element,function() {
					scope.$apply(function() {
						place();
					});
				});

				$(document).on('ADE_hidepops.ADE',function() {
					saveEdit(3);
				});
			};

			//setup events
			if(!readonly) {
				element.on('click.ADE', function(e) {
					scope.$apply(function() {
						clickHandler(e);
					});
				});
			}

			//A callback to observe for changes to the id and save edit
			//The model will still be connected, so it is safe, but don't want to cause problems
			var observeID = function(value) {
				 //this gets called even when the value hasn't changed, 
				 //so we need to check for changes ourselves
				 if(editing && adeId!==value) saveEdit(3);
				 else if(adeId!==value) ADE.hidePopup(element);
			};

			//If ID changes during edit, something bad happened. No longer editing the right thing. Cancel
			stopObserving = attrs.$observe('adeId', observeID);

			var destroy = function() {
				ADE.teardownScrollEvents(element);
				ADE.hidePopup(element);
				ADE.teardownBlur();
				if(input) {
					input.off();
					input.remove();
				}
				if(element) {
					var editLinkNode = element.next('.ade-links').find('.ade-edit-link');
					if(editLinkNode) editLinkNode.off('click.ADE');
					if(invisibleInput) invisibleInput.off('blur.ADE');
				}
				$(document).off('ADE_hidepops.ADE');
			};

			scope.$on('$destroy', function() { //need to clean up the event watchers when the scope is destroyed
				destroy();

				if(element) element.off('.ADE');

				if(stopObserving && stopObserving!=observeID) { //Angualar <=1.2 returns callback, not deregister fn
					stopObserving();
					stopObserving = null;
				} else {
					delete attrs.$$observers['adeId'];
				}
			});

			//need to watch the model for changes
			scope.$watch(function(scope) {
				return scope.ngModel;
			}, function () {
				makeHTML();
			});
		}
	};
}]);

/* ==================================================================
  	AngularJS Datatype Editor - Date
  	A filter to display a date. It is a wrapper for Angular's date filter
  	that provides better display for invalid values and handles timezones differently.

	The input can be a unix timestamp(integer), a human readable time string(string) or 
	an array [timestamp,absolutetimestamp,timezone]. If it is an array:

	timestamp 			 = the true unix timestamp that represents this date.
								For example if someone in California chooses "July 15, 2013 6:00:00 PM"
								it will store 1373936400 (16 Jul 2013 01:00:00 GMT)

	absolutetimestamp  = a timestamp that represents the user's selected date as if they were in the GMT timezone
								For example, if someone in California chooses "July 15, 2013 6:00:00 PM"
								it will store 1373911200 (15 Jul 2013 18:00:00 GMT)

	timezone 			 = the number of minutes that the setter is off from GMT. Typically this will be equal
								to (timestamp-absolutetimestamp)/60, but may not if daylight savings time is in 
								affect. It should be the value returned from getTimezoneOffset() for the user.

	The filter parameter can be a dateFormat string, or an array [format, absolute, showTimezone]

	dateFormat 			 = a string format for the date "medium" or "mediumData" or "yyyy" or ...

	absolute 	 = a boolean if we should display the time as absolute(true) or relative(false)

	showTimezone	 = a boolean if we should display the user's timezone if different from the set timezone

	There are two scenarios for picking and displaying dates.

	Scenario #1
	The user picks July 15 6:00pm and you want to display July 15 6:00pm regardless of there the user is.
	If the user travels from California to New York, it will still display 6:00pm. This is what we are
	calling "absolute time" and you tell this filter to display dates in this way by passing true
	to the second option. The third boolean controls if the timezone offset is appended to the end of the 
	string if different from the display user's timezone.  For example (+1 h)

	Scenario #2
	The user picks July 15 6:00pm and you want to display July 15 6:00pm as long as they stay put. If the
	user travels to a different timezone, we will convert it to the new timezone and display the new
	time.  This is what we are calling "floating time" and you tell this filter to display dates in
	this way by passing false to the second option. The third boolean is ignored in this scenario.

  	Usage:
  	{{ "2013-01-01" | validDate:'yyyy' }}
  	{{ 1373936400 | validDate:'yyyy' }}
  	{{ [1373936400,1373911200,420] | validDate:['yyyy',true,true] }}

------------------------------------------------------------------*/

angular.module('ADE').filter('validDate', ['$filter', function($filter) {
	return function(input, options) {
		if (angular.isUndefined(input)) return '';

		//if input is string, make it an array
		if(angular.isString(input)) {
			var split = input.split(',');
		 	if(split.length==3) input = split; //only use the split if it has 3 pieces, otherwise it may be a preformated data (Jan 1, 2013)
		}

		//pick apart the data array
		var timestamp = input;
		var absolutetimestamp = input; //difference between these two is the setter's timezone offset
		var timezone = '';
		if (angular.isArray(input)) { //if input is an array, pull out the pieces
			timestamp = parseInt(input[0]);
			absolutetimestamp = parseInt(input[1]);
			timezone = parseInt(input[2]);
			if(!absolutetimestamp) absolutetimestamp = timestamp;
			if(!timestamp) timestamp = absolutetimestamp;
		}

		//pick apart the options array
		var dateFormat = options;
		var absolute = true;
		var showTimezone = false;
		if (angular.isArray(options)) { //if input is an array, pull out the pieces
			dateFormat = options[0];
			if(options[1]!==undefined) absolute = options[1];
			if(options[2]!==undefined) showTimezone = options[2];
		}

		if (!input || !timestamp) return '';

		if (angular.isString(timestamp)) {
			var number = parseInt(timestamp);
			if (timestamp === number + '') {
				timestamp = number;
			} else {
				var date = Date.parse(timestamp); //use date.js library to interpret string
				if (date !== null) {
					timestamp = date.toUnixTimestamp();
				} else {
					timestamp = null;
				}
				absolutetimestamp = timestamp;
			}
		}

		var output = '';
	
		if (absolute && absolutetimestamp!==null) { //we want to display fixed GMT time regardless of user's timezone
			//need to get timezoneoffset of absolute time to account for daylight savings time
			var currentOffset = new Date(absolutetimestamp*1000).getTimezoneOffset(); //minutes

			//to do this, we need to artifically offset the time by the user's timezone offset
			absolutetimestamp += currentOffset * 60;
			output = $filter('date')(absolutetimestamp * 1000, dateFormat);

			//determine if we need to append the timezone information to the string
			if(showTimezone && currentOffset !== timezone) {
				var offset = (currentOffset-timezone)/60;
				if(offset>0) offset = "+"+offset;
				output += " ("+offset+" h)";
			}
		} else if(timestamp!==null){ //display in local time
			output = $filter('date')(timestamp * 1000, dateFormat);
		}

		// console.log(timestamp,absolutetimestamp,timezone,dateFormat,absolute,showTimezone,output);

		return output;
  	};
}]);

/* ==================================================================
	AngularJS Datatype Editor - Date
	Two directives to edit a date. One directive is responsible for creating a popup 
	calendar on an input. The second direcrtive is responsible for creating that input
	when clicking on a date.

------------------------------------------------------------------*/


/* ==================================================================
	Directive to present a date picker popup on an input element

	Usage:
	<input ade-calpop='mm/dd/yyyy' ng-model="data"></div>

	Config:

	ade-calpop:
		Specify the format that you want the date displayed in.  Defaults to mm/dd/yyy.
		Can be 'yyyy' or 'MMM d, yyyy' or 'MMM d, yyyy h:mm:ss a' or something else.
	ade-yearonly:
		"1" to allow only the year to be selected (no month or day)

------------------------------------------------------------------*/

angular.module('ADE').directive('adeCalpop', ['$filter', function($filter) {
	return {
		require: '?ngModel', //optional dependency for ngModel
		restrict: 'A', //Attribute declaration eg: <div ade-calpop=""></div>

		scope: {
			adeCalpop: "@",
			adeYearonly: "@",
			ngModel: "="
		},

		//The link step (after compile)
		link: function(scope, element, attrs) {
			var options = {format: 'mm/dd/yyyy'};
			if(scope.adeCalpop!==undefined) options.format = scope.adeCalpop;

			if(scope.adeYearonly!==undefined && scope.adeYearonly=="1") {
				options.viewMode = 2; //tells the datepicker to start on year picker
				options.minViewMode = 2;//tells the datepicker to limit to year only
			}

			//iOS has a good native picker for input type=date, so use it?
			// var userAgent = window.navigator.userAgent;
			// var nativePicker = false;
			// if(userAgent.match(/iPad/i) || userAgent.match(/iPhone/i)) {
			// 	nativePicker = true;
			// }

			//creates a callback for when something is picked from the popup or typed
			var updateModel = function(e) {
				// console.log("updateModel",e.date,e.external,e.wasClick);
				var dateStr = "";
				if(e && e.date && e.external==undefined && e.wasClick) { //change came from click on calendar
					dateStr = $filter('date')(e.date, options.format); //turn timestamp into string
					scope.ngModel = dateStr;
					// console.log("wasClick",dateStr);
				} else if(e.external && e.date) { //change came from typing or external change
					if(angular.isNumber(e.date)) {
						dateStr = $filter('date')(e.date, options.format); //turn timestamp into string
					} else {
						dateStr = e.date;
					}
					// console.log("wasExternal",dateStr);

					element.datepicker('setValue', dateStr);					
				} else if(e.external) {
					element.datepicker('setValue', null);
				}
			};
			
			//initialization of the datapicker
			element.datepicker(options).on('changeDate.ADE',function(e) {
				//sometimes this is called inside Angular scope, sometimes not.
				//scope.$$phase is always null for some reason so can't check it
				//instead I am putting it in a timer to take it out of angular scope
				window.setTimeout(function() { 
					scope.$apply(function() { //we then put it back into angular scope
						updateModel(e);
					});
				});
			});

			if(scope.ngModel) {
				element.datepicker('setValue', scope.ngModel);
				
			}

			//Handles keys pressed on in-line text box
			element.on('keydown.ADE', function(e) {
				var keyCode = (e.keyCode ? e.keyCode : e.which); //firefox doesn't register keyCode on keypress only on keyup and down
				
				if (keyCode == 27) { //esc key
					element.datepicker('hide');
				} else if (keyCode == 13) { //return
					element.datepicker('typedReturn',e);
				} else if (keyCode == 9) { //tab
					element.datepicker('hide');
				} else {
					element.datepicker('show');
				}
			});
			
			var destroy = function() { //need to clean up the event watchers when the scope is destroyed
				if(element) {
					element.off('keypress.ADE');
					element.off('changeDate.ADE');
					if(element.datepicker) {
						element.datepicker('hide');
						element.datepicker('remove');
					}
				}
				if(unwatch) unwatch();
			};

			scope.$on('$destroy', destroy);

			//need to watch the model for changes
			var unwatch = scope.$watch(function(scope) {
				return scope.ngModel;
			}, function () {
				//updateModel is expecting a certain object from the popup calendar
				//so we have to simulate it, but add external flag so we can handle it differently
				if(scope.ngModel===-2) destroy();
				else updateModel({date:scope.ngModel,external:true});
			});

		}
	};
}]);

/* ==================================================================
	Directive to display an input box and a popup date picker on a div that is clicked on

	Usage:
	<div ade-date='mm/dd/yyyy' ade-id='1234' ade-class="myClass" ng-model="data"></div>

	Config:

	ade-date:
		Specify the format that you want the date displayed in.  Defaults to mm/dd/yyy.
		Can be 'yyyy' or 'MMM d, yyyy' or 'MMM d, yyyy h:mm:ss a' or something else.
	ade-id:
		If this id is set, it will be used in messages broadcast to the app on state changes.
	ade-class:
		A custom class to give to the input
	ade-readonly:
		If you don't want the date to be editable
	ade-absolute:
		"1" if you want the date to be displayed in absolute time instead of relative time.
		See the documentation for the date filter for more info about this.
	ade-timezome:
		"1" if you want the timezone to be displayed if different from current timezone

	Messages:
		name: ADE-start
		data: id from config

		name: ADE-finish
		data: {id from config, old value, new value, exit value}


------------------------------------------------------------------*/
angular.module('ADE').directive('adeDate', ['ADE', '$compile', '$filter', function(ADE, $compile, $filter) {
	return {
		require: '?ngModel', //optional dependency for ngModel
		restrict: 'A', //Attribute declaration eg: <div ade-date=""></div>

		scope: {
			adeDate: "@",
			adeId: "@",
			adeClass: "@",
			adeReadonly: "@",
			adeAbsolute: "@",
			adeTimezone: "@",
			adeHover: "@",
			adeButton: "@",
			ngModel: "="
		},

		//The link step (after compile)
		link: function(scope, element, attrs) {
			var editing = false;
			var input = null;
			var parent = null; //the optional container for the input
			var button = null; //the optional cal button for an input
			var exit = 0; //0=click, 1=tab, -1= shift tab, 2=return, -2=shift return. controls if you exited the field so you can focus the next field if appropriate
			var readonly = false;
			var inputClass = "";
			var format = 'mm/dd/yyyy';
			var absolute = false;
			var timezone = false;
			var stringDate = ""; //The string displayed to the user after conversion from timestamp
			var stopObserving = null;
			var adeId = scope.adeId;
			var blurTimeout = null; //delay for bluring the event so a button can cancel

			if(scope.adeDate!==undefined) format = scope.adeDate;
			if(scope.adeClass!==undefined) inputClass = scope.adeClass;
			if(scope.adeHover!==undefined && scope.adeHover=="0") scope.adeHover = false; else scope.adeHover=true;
			if(scope.adeReadonly!==undefined && scope.adeReadonly=="1") readonly = true;
			if(scope.adeAbsolute!==undefined && scope.adeAbsolute=="1") absolute = true;
			if(scope.adeTimezone!==undefined && scope.adeTimezone=="1") timezone = true;

			var makeHTML = function() {				
				stringDate = $filter('validDate')(scope.ngModel,[format,absolute,timezone]);
				element.html(stringDate);
			};

			var parseDateString = function(s) {
				var date = Date.parse(s);
				if (date != null) {
					var time = date.toUnixTimestamp();
					return time;
				}
				return null;
			};

			//callback once the edit is done
			var saveEdit = function(exited) {

				var oldValue = scope.ngModel;
				exit = exited;
				
				if (exited != 3) { //don't save value on esc
					var value = parseDateString(input.val());
					if (value == null || value==0) {
						value = [0,0,0];
					} else {
						var offset = new Date(value*1000).getTimezoneOffset();
						value = [value, value-offset*60, offset];
					}
					scope.ngModel = value;
				}
				element.show();

				ADE.teardownBlur(input);
				ADE.teardownKeys(input);

				scope.adePickDate = -2;
				if(input) input.remove(); //remove the input
				if(parent) parent.remove();

				editing = false;

				ADE.done(adeId, oldValue, scope.ngModel, exit);
			};

			var clickHandler = function() {
				ADE.hidePopup(element);
				destroy();
				if (editing) return;
				editing = true;
				exit = 0;

				var preset = scope.ngModel;
				
				//model should be an array [localtime, absolutetime, timezone]
				//find the proper time and convert it to a string
				if(angular.isArray(scope.ngModel) && scope.ngModel.length>0) {
					preset = scope.ngModel[0];//start with local
					if(scope.adeAbsolute && scope.ngModel[1]!==undefined) { //pick absolute if requested
						preset = scope.ngModel[1]; //the GMT time we want to display, so need to offset this by user's offset
						if(preset) preset += new Date(preset*1000).getTimezoneOffset()*60;
					}
				}

				if(angular.isString(preset)) {
					var number = parseInt(preset.replace(/[$]/g, ''));
					if(preset===number+'') preset = number;
					else preset = parseDateString(preset);
				} else if(!angular.isNumber(preset)) {
					preset = 0;
				}
				preset = preset ? preset : 0; //preset should now be a unix timestamp for the displayed time

				adeId = scope.adeId;
				ADE.begin(adeId);

				scope.adePickDate = stringDate;

				element.hide();
				var html;
				var extraDPoptions = '';
				if (format == 'yyyy') extraDPoptions = 'ade-yearonly="1"';
				if(scope.adeButton!==undefined && scope.adeButton=="1") {
					//directive specifies a button accessor instead of input attached
					html='<div class="input-append ade-date-popup"><input ng-model="adePickDate" type="text" class="' + inputClass + '" />';
					html+='<span class="add-on"><i class="icon-calendar" ade-calpop="'+format+'" '+extraDPoptions+' ng-model="adePickDate"></i></span></div>';
					$compile(html)(scope).insertAfter(element);
				
					parent = element.next('.input-append'); 
					input = parent.children('input');
					button = parent.children('.add-on').children('i');

					button.on('click touchstart', function() {
						ADE.cancelBlur();
					}).on('hide',function(e) {						
						//allow focus on input to cancel the blur of the calendar
						if(blurTimeout) clearTimeout(blurTimeout);
						blurTimeout = window.setTimeout(function() {
							blurTimeout = false;
							saveEdit(0);
						},100);
					});
					input.on('focus',function() {
						if(blurTimeout) {
							clearTimeout(blurTimeout);
							blurTimeout = false;
						}
					});

					ADE.setupBlur(input, saveEdit, scope, false);

					button.datepicker('show');


				} else {
					html = '<input ade-calpop="'+format+'" '+extraDPoptions+' ng-model="adePickDate" type="text" class="' + inputClass + '" />';
					$compile(html)(scope).insertAfter(element);
					
					input = element.next('input');
					input.focus(); //I do not know why both of these are necessary, but they are
					window.setTimeout(function() {
						input.focus();
					});

					ADE.setupBlur(input, saveEdit, scope, true);
				}

				ADE.setupKeys(input, saveEdit, false, scope);
			};

			//place the popup in the proper place on the screen
			var place = function() {
				ADE.place('.'+ADE.popupClass,element,15,-5);
			};

			//When mousing over the div it will display a popup with the day of the week
			if(!('ontouchstart' in window) && scope.adeHover) {
				element.on('mouseover.ADE', function() {
					ADE.hidePopup();
					var value = element.text();
					if (value === "" || value.length <= 4) return;
					//strip off timezone if present
					var hastimezone = value.indexOf("(");
					if(hastimezone>0) value = value.substring(0,hastimezone);

					var today = Date.today();
					var inputDate = Date.parse(value);
					if(inputDate==undefined || inputDate==null) return; //couldn't parse date
					var dayOfWeek = inputDate.toString("dddd");
					var future = (today.isAfter(inputDate)) ? false : true;
					var diff = Math.abs(new TimeSpan(inputDate - today).days);
					var dayOrDays = (diff === 1) ? " day" : " days";
					var content = (future) ? "In " + diff + dayOrDays + ". " : diff + dayOrDays + " ago. ";
					if (diff === 0) content = "Today is ";
					var html = '<div class="' + ADE.popupClass + ' ade-date-popup dropdown-menu open"><p>' + content + dayOfWeek + '.</p></div>';
					$compile(html)(scope).insertAfter(element);
					place();

					ADE.setupScrollEvents(element,function() {
						scope.$apply(function() {
							place();
						});
					});

				});
			}

			//Remove the day of the week popup
			element.on('mouseout.ADE', function() {
			  ADE.hidePopup(element);
			  destroy();
			});

			if(!readonly) {
				element.on('click.ADE', clickHandler); //this doesn't need to be wrapped in $apply because calPop does it
			}

			//A callback to observe for changes to the id and save edit
			//The model will still be connected, so it is safe, but don't want to cause problems
			var observeID = function(value) {
				 //this gets called even when the value hasn't changed, 
				 //so we need to check for changes ourselves
				 if(editing && adeId!==value) saveEdit(3);
			};

			//If ID changes during edit, something bad happened. No longer editing the right thing. Cancel
			stopObserving = attrs.$observe('adeId', observeID);

			var destroy = function() {
				ADE.teardownScrollEvents(element);
			};

			scope.$on('$destroy', function() { //need to clean up the event watchers when the scope is destroyed
				destroy();

				if(element) {
					element.off('mouseover.ADE');
					element.off('mouseout.ADE');
					element.off('click.ADE');
				}

				if(stopObserving && stopObserving!=observeID) { //Angualar <=1.2 returns callback, not deregister fn
					stopObserving();
					stopObserving = null;
				} else {
					delete attrs.$$observers['adeId'];
				}
				if(unwatch) unwatch();
			});

			//need to watch the model for changes
			var unwatch = scope.$watch(function(scope) {
				return scope.ngModel;
			}, function () {
				makeHTML();
			});

		}
	};
}]);


/*
References

https://groups.google.com/forum/?fromgroups=#!topic/angular/ERUVRR8vZW0
http://www.eyecon.ro/bootstrap-datepicker/
https://gist.github.com/3103533
https://gist.github.com/3135128

Alternative: https://github.com/angular-ui/angular-ui/tree/master/modules/directives/date

http://docs.angularjs.org/guide/directive
*/

/* =========================================================
	Modifications made by https://github.com/Toodledo/ADE

	1) Added comments so I could better understand the code
	2) Better handling for case where no date is preset
	3) Allows canceling of the calendar without setting a date
	4) Enabled full text parsing of unrecognized dates via an external date.js library.
		So you can type "next week" and it should work
	5) Got rid of date formatting and allowed caller to take care of this
	6) Method for destroying the calendar DOM object
	7) Remove unnecessary changeDate events
	8) Added wasClick boolean to event so we can tell how the date was changed
	9) Supresses notifications when nothing actually changed
	10) Make full screen on small windows
	11) Get popup calendar to position correctly on resize/scroll of window
 * ========================================================= */


/* =========================================================
 * bootstrap-datepicker.js
 * http://www.eyecon.ro/bootstrap-datepicker
 * =========================================================
 * Copyright 2012 Stefan Petre
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================= */

!function($) {

	//Initialization
	var Datepicker = function(element, options) {
		this.element = $(element);
		this.picker = $(DPGlobal.template)
							.appendTo('body')
							.on({
								click: $.proxy(this.click, this),
								touchend: $.proxy(this.touched, this),
								mousedown: $.proxy(this.mousedown, this)
							});
		this.isInput = this.element.is('input');
		this.component = this.element.is('.date') ? this.element.find('.add-on') : false;

		if (this.isInput) {
			this.element.on({
				focus: $.proxy(this.show, this),
				blur: $.proxy(this.hide, this),
				keyup: $.proxy(this.update, this)
			});
		} else {
			if (this.component) {
				this.component.on('click', $.proxy(this.show, this));
			} else {
				this.element.on('click', $.proxy(this.show, this));
			}
		}
		this.minViewMode = options.minViewMode || this.element.data('date-minviewmode') || 0;
		if (typeof this.minViewMode === 'string') {
			switch (this.minViewMode) {
				case 'months':
					this.minViewMode = 1;
					break;
				case 'years':
					this.minViewMode = 2;
					break;
				default:
					this.minViewMode = 0;
					break;
			}
		}
		this.viewMode = options.viewMode || this.element.data('date-viewmode') || 0;
		if (typeof this.viewMode === 'string') {
			switch (this.viewMode) {
				case 'months':
					this.viewMode = 1;
					break;
				case 'years':
					this.viewMode = 2;
					break;
				default:
					this.viewMode = 0;
					break;
			}
		}
		this.startViewMode = this.viewMode;
		this.weekStart = options.weekStart || this.element.data('date-weekstart') || 0;
		this.weekEnd = this.weekStart === 0 ? 6 : this.weekStart - 1;
		this.onRender = options.onRender;
		this.fillDow();
		this.fillMonths();
		this.update();
		this.showMode();
	};

	Datepicker.prototype = {
		constructor: Datepicker,

		show: function(e) {
			this.picker.show();
			this.height = this.component ? this.component.outerHeight() : this.element.outerHeight();
			this.place();
			$(window).off('resize.boot');
			$(window).on('resize.boot', $.proxy(this.place, this));
			$(document).off('scroll.boot');
			$(document).on('scroll.boot', $.proxy(this.place, this));
			if (e) {
				e.stopPropagation();
				e.preventDefault();
			}
			if (!this.isInput) {
				$(document).off('mousedown.boot');
				$(document).on('mousedown.boot', $.proxy(this.hide, this));
			}
			$(document).off('touchstart.boot');
			$(document).on('touchstart.boot', $.proxy(this.touchstart, this));

			this.element.trigger({
				type: 'show',
				date: this.date
			});
		},

		//Added to support touch devices like iOS
		touchstart: function() {
			// console.log("touchstart");
			$(document).off('touchmove.boot');
			$(document).off('touchend.boot');
			$(document).on('touchend.boot', $.proxy(this.touchend, this));
			$(document).on('touchmove.boot', function() {
				//if we moved, its not a touch anymore, so cancel the touchend
				// console.log("touchmove");
				$(document).off('touchmove.boot');
				$(document).off('touchend.boot');
			});
		},

		touchend: function() {
			$(document).off('touchmove.boot');
			$(document).off('touchend.boot');

			// console.log("touchend",this.touchTimeout);
			var that = this;
			if(this.touchTimeout) { //double tap 
				//cancel previous and do nothing. Allow OS to zoom
				// console.log("double clear");
				clearTimeout(this.touchTimeout);
				this.touchTimeout = false;
				return;
			}	
			this.touchTimeout = setTimeout(function() {
				// console.log("touch timeout");
				if(that.isInput) {
					that.element.blur();
				} else {
					that.hide();
				}
				that.touchTimeout = false;
			},350); //wait a little bit (at least 300ms) before bluring to allow a valid touch to cancel the blur
		},

		hide: function() {
			// console.log("hide");
			this.picker.hide();
			$(window).off('resize.boot');
			$(document).off('scroll.boot');
			this.viewMode = this.startViewMode;
			this.showMode();
			if (!this.isInput) {
				$(document).off('mousedown.boot');
			}
			$(document).off('touchstart.boot');
			$(document).off('touchend.boot');
			$(document).off('touchmove.boot');

			this.wasClick=false;
			this.set();
			this.element.trigger({
				type: 'hide',
				date: this.date
			});
		},

		//You can pass in the event when a return key is pressed on the parent input
		//and use this to hide the calendar the first time it is pressed
		//the second time it is pressed it will do the default action (submit form perhaps)
		typedReturn: function(e) {
			if(this.picker.is(':visible')) {
				e.preventDefault();
				e.stopPropagation();
				this.hide();
			}
		},

		remove: function() {
			this.picker.remove();
		},

		//value is set by clicking, on hide, or external setting
		set: function() {

			if(this.touchTimeout) { //cancel the touch timeout because we don't want to blur for this touch
				// console.log("set clear");
				clearTimeout(this.touchTimeout);
				this.touchTimeout = false;
			}

			// var returnObj = [];
			// if (this.date) {
			//  	returnObj = [this.date.getTime(), this.date.getTime()-this.date.getTimezoneOffset()*60000, this.date.getTimezoneOffset()];
			// } else {
			//   	returnObj = null;
			// }

			this.element.trigger({
				type: 'changeDate',
				date: this.date ? this.date.getTime() : null,
				wasClick: this.wasClick
				//date: returnObj
			});
			return;
		},

		//a public function to programatically update the selected date
		setValue: function(newDate) {
			this.wasClick = false;
			var oldDate = this.date;

			if (!newDate) {
				this.date = null;
			} else if (typeof newDate === 'string') {
				this.date = DPGlobal.parseDate(newDate);
			} else {
				this.date = new Date(newDate * 1000);
			}
			
			if(!oldDate || !this.date || oldDate.getTime()!=this.date.getTime()) {
				// console.log("setValue",oldDate,this.date);
				this.set(); //only set if it has changed
			}

			if (newDate && this.date) {
				this.viewDate = new Date(this.date.getFullYear(), this.date.getMonth(), 1, 0, 0, 0, 0);
			} else {
				this.viewDate = new Date();
			}
			this.fill();
		},

		//place the popup in the proper place on the screen
		place: function() {
			var offset = this.component ? this.component.offset() : this.element.offset();
			var windowW = $(window).width();
			var scroll = $(window).scrollLeft();

			this.picker.removeClass("rarrow");
			if(windowW<=480) {
				offset.left = scroll+5;
			} else {
				var pickerRight = offset.left + this.picker[0].offsetWidth;

				//Move to the left if it would be off the right of page
				if (pickerRight-scroll > windowW) {
					offset.left = offset.left - this.picker[0].offsetWidth + 30;
					this.picker.addClass("rarrow");
				}
			}
			this.picker.css({ top: offset.top + this.height, left: offset.left });
			
			//flip up top if off bottom of page
			var windowH = $(window).height();
			var scroll = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop;
			var pickerHeight = this.picker[0].offsetTop + this.picker[0].offsetHeight;

			if (pickerHeight - scroll > windowH) {
				this.picker.css({
					top: offset.top - this.picker[0].offsetHeight - 5
				}).addClass("flipped");
			} else {
       	 	this.picker.removeClass("flipped");
      	}
		},

		//each time a keystroke is fired on the input
		update: function(newDate) {
			this.date = DPGlobal.parseDate(
				typeof newDate === 'string' ? newDate : (this.isInput ? this.element.prop('value') : this.element.data('date'))
			);

			if (this.date) {
				this.viewDate = new Date(this.date.getFullYear(), this.date.getMonth(), 1, 0, 0, 0, 0);
			} else {
				this.viewDate = new Date();
			}
			this.fill();
		},

		//draws the days of week
		fillDow: function() {
			var dowCnt = this.weekStart;
			var html = '<tr>';
			while (dowCnt < this.weekStart + 7) {
				html += '<th class="dow">' + DPGlobal.dates.daysMin[(dowCnt++) % 7] + '</th>';
			}
			html += '</tr>';
			this.picker.find('.datepicker-days thead').append(html);
		},

		//draws the month picker
		fillMonths: function() {
			var html = '';
			var i = 0;
			while (i < 12) {
				html += '<span class="month">' + DPGlobal.dates.monthsShort[i++] + '</span>';
			}
			this.picker.find('.datepicker-months td').append(html);
		},

		//redraws the calendar
		fill: function() {
			var d = new Date(this.viewDate);
			var year = d.getFullYear();
			var month = d.getMonth();
			var today = new Date();
			var todayDay = today.getDate();
			var todayMonth = today.getMonth();

			//set currentDate to timestamp of date without time component
			var currentDate = null;
			if (this.date) {
				currentDate = new Date(this.date.getFullYear(), this.date.getMonth(), this.date.getDate()).valueOf();
			}

			// console.log("fill",currentDate);

			this.picker.find('.datepicker-days th:eq(1)').text(DPGlobal.dates.months[month] + ' ' + year); //updates the calendar month/year title

			//setup previous and next month objects for edges of calendar
			var prevMonth = new Date(year, month - 1, 28, 0, 0, 0, 0);
			var day = DPGlobal.getDaysInMonth(prevMonth.getFullYear(), prevMonth.getMonth());
			prevMonth.setDate(day); //sets to last day of the month
			prevMonth.setDate(day - (prevMonth.getDay() - this.weekStart + 7) % 7); //moves it back to the begining of this week
			var nextMonth = new Date(prevMonth);
			nextMonth.setDate(nextMonth.getDate() + 42); //42 is the number of cells displayed on the calendar
			nextMonth = nextMonth.valueOf(); //sets to unix timestamp to the last visible day in the calendar
			var html = [];
			var clsName,
				prevY,
				prevM;
			while (prevMonth.valueOf() < nextMonth) { //loop through first day to last day of visible days
				if (prevMonth.getDay() === this.weekStart) {
					html.push('<tr>');
				}
				clsName = this.onRender(prevMonth);
				prevY = prevMonth.getFullYear();
				prevM = prevMonth.getMonth();
				if ((prevM < month &&  prevY === year) ||  prevY < year) {
					clsName += ' old';
				} else if ((prevM > month && prevY === year) || prevY > year) {
					clsName += ' new';
				}
				if (prevMonth.valueOf() === currentDate) {
					clsName += ' active';
				}
				if (prevMonth.getMonth() === todayMonth && prevMonth.getDate() === todayDay) {
					clsName += ' today';
				}
				html.push('<td class="day' + clsName + '">' + prevMonth.getDate() + '</td>');
				if (prevMonth.getDay() === this.weekEnd) {
					html.push('</tr>');
				}
				prevMonth.setDate(prevMonth.getDate() + 1);
			}
			this.picker.find('.datepicker-days tbody').empty().append(html.join(''));

			//updates month picker
			var currentYear = this.date ? this.date.getFullYear() : null;
			var months = this.picker.find('.datepicker-months')
						.find('th:eq(1)')
							.text(year)
							.end()
						.find('span').removeClass('active');
			if (currentYear === year) {
				var currentMonth = this.date ? this.date.getMonth() : null;
				if (currentMonth) months.eq(currentMonth).addClass('active');
			}

			//updates year picker
			html = '';
			year = parseInt(year / 10, 10) * 10;
			var yearCont = this.picker.find('.datepicker-years')
								.find('th:eq(1)')
									.text(year + '-' + (year + 9))
									.end()
								.find('td');
			year -= 1;
			for (var i = -1; i < 11; i++) {
				html += '<span class="year' + (i === -1 || i === 10 ? ' old' : '') + (currentYear === year ? ' active' : '') + '">' + year + '</span>';
				year += 1;
			}
			yearCont.html(html);
		},

		touched: function(e) {
			// console.log("touched",e);
			this.click(e);
		},

		//updates the calendar's state and selected value and sends the message that the value changed
		click: function(e) {
			// console.log("click",e);
			e.stopPropagation();
			e.preventDefault();

			if(this.touchTimeout) { //cancel the touch timeout because we don't want to blur for this touch
				// console.log("click clear");
				clearTimeout(this.touchTimeout);
				this.touchTimeout = false;
			}

			var target = $(e.target).closest('span, td, th');
			if (target.length === 1) {
				switch (target[0].nodeName.toLowerCase()) {
					case 'th':
						switch (target[0].className) {
							case 'switch': //clicked on the month/year to enter the switcher
								this.showMode(1);
								break;
							case 'prev':
							case 'next':
								this.viewDate['set' + DPGlobal.modes[this.viewMode].navFnc].call(
									this.viewDate,
									this.viewDate['get' + DPGlobal.modes[this.viewMode].navFnc].call(this.viewDate) +
									DPGlobal.modes[this.viewMode].navStep * (target[0].className === 'prev' ? -1 : 1)
								);
								this.fill();
								this.set();
								break;
						}
						break;
					case 'span':
						if (target.is('.month')) {
							var month = target.parent().find('span').index(target);
							this.viewDate.setMonth(month);
						} else {
							var year = parseInt(target.text(), 10) || 0;
							this.viewDate.setFullYear(year);
						}
						if (this.viewMode !== 0) {
							this.date = new Date(this.viewDate);
							// ADE: Dont need this hear because it happens in set() three lines down
							// this.element.trigger({
							// 	type: 'changeDate',
							// 	date: this.date,
							// 	viewMode: DPGlobal.modes[this.viewMode].clsName
							// });
						}
						this.wasClick = true;
						this.showMode(-1);
						this.fill();
						this.set();
						break;
					case 'td':
						if (target.is('.day')) {
							var day = parseInt(target.text(), 10) || 1;
							var month = this.viewDate.getMonth();
							if (target.is('.old')) {
								month -= 1;
							} else if (target.is('.new')) {
								month += 1;
							}
							var year = this.viewDate.getFullYear();
							var oldDate = this.date;
							this.date = new Date(year, month, day, 0, 0, 0, 0);
							this.viewDate = new Date(year, month, Math.min(28, day), 0, 0, 0, 0);
							this.wasClick = true;
							this.fill();
							
							if(!oldDate || oldDate.getTime()!=this.date.getTime()) {
								// console.log("click",oldDate,this.date);
								this.set(); //only set if it has changed
							}
					 		// ADE: Dont need this hear because it happens in set() one line up
							//this.element.trigger({
							//	type: 'changeDate',
							//	date: this.date,
							//	viewMode: DPGlobal.modes[this.viewMode].clsName
							//});
						}
						break;
				}
			}
		},

		mousedown: function(e) {
			// console.log("mousedown");
			e.stopPropagation();
			e.preventDefault();
		},

		showMode: function(dir) {
			if (dir) {
				this.viewMode = Math.max(this.minViewMode, Math.min(2, this.viewMode + dir));
			}
			this.picker.find('>div').hide().filter('.datepicker-' + DPGlobal.modes[this.viewMode].clsName).show();
		}
	};

	$.fn.datepicker = function(option, val) {
		return this.each(function() {
			var $this = $(this),
				data = $this.data('datepicker'),
				options = typeof option === 'object' && option;
			if (!data) {
				$this.data('datepicker', (data = new Datepicker(this, $.extend({}, $.fn.datepicker.defaults, options))));
			}
			if (typeof option === 'string') data[option](val);
		});
	};

	$.fn.datepicker.defaults = {
		onRender: function(date) {
			return '';
		}
	};
	$.fn.datepicker.Constructor = Datepicker;

	var DPGlobal = {
		modes: [
			{
				clsName: 'days',
				navFnc: 'Month',
				navStep: 1
			},
			{
				clsName: 'months',
				navFnc: 'FullYear',
				navStep: 1
			},
			{
				clsName: 'years',
				navFnc: 'FullYear',
				navStep: 10
		}],
		dates: {
			days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'],
			daysShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
			daysMin: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa', 'Su'],
			months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
			monthsShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
		},
		isLeapYear: function(year) {
			return (((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0));
		},
		getDaysInMonth: function(year, month) {
			return [31, (DPGlobal.isLeapYear(year) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
		},
		
		parseFormat: function(format){
			var separator = format.match(/[.\/\-\s].*?/),
				parts = format.split(/\W+/);
			if (!separator || !parts || parts.length === 0){
				throw new Error("Invalid date format.");
			}
			return {separator: separator, parts: parts};
		},
		
		//attemps to parse the incoming date into day, month and year.
		parseDate: function(dateStr) {
			if (!dateStr) return null;
			var date = new Date.parse(dateStr);
			if(typeof date.getTime === "undefined") date = new Date();

			if(!date) return null;
			return date;
		},

		//templates for making the calendar HTML
		headTemplate: '<thead>' +
							'<tr>' +
								'<th class="prev">&lsaquo;</th>' +
								'<th colspan="5" class="switch"></th>' +
								'<th class="next">&rsaquo;</th>' +
							'</tr>' +
						'</thead>',
		contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>'
	};
	DPGlobal.template = '<div class="datepicker dropdown-menu">' +
							'<div class="datepicker-days">' +
								'<table class=" table-condensed">' +
									DPGlobal.headTemplate +
									'<tbody></tbody>' +
								'</table>' +
							'</div>' +
							'<div class="datepicker-months">' +
								'<table class="table-condensed">' +
									DPGlobal.headTemplate +
									DPGlobal.contTemplate +
								'</table>' +
							'</div>' +
							'<div class="datepicker-years">' +
								'<table class="table-condensed">' +
									DPGlobal.headTemplate +
									DPGlobal.contTemplate +
								'</table>' +
							'</div>' +
						'</div>';

}(window.jQuery);

/* ==================================================================
	AngularJS Datatype Editor - Decimal
	A filter to display a number as a decimal
	Wrapper for Angular's built in filter so that we can display
	invalid inputs correctly.
	
	Usage:
	{{ data | decimal:2 }}

------------------------------------------------------------------*/

angular.module('ADE').filter('decimal', ['$filter',function($filter) {

	return function(input, fractionSize) {
		var output = '';
		var fractionSize = fractionSize || 2;

		if (angular.isArray(input)) input = input[0];
		if (angular.isString(input)) input = parseFloat(input);
		if (angular.isUndefined(input) || !angular.isNumber(input)) return output;

		output = $filter('number')(input,fractionSize);

  		return output;
	 };
}]);


/* ==================================================================
	AngularJS Datatype Editor - Email
	
	This is probably not necessary, but in case it becomes necessary
	here it is.

	Usage:
	{{ data | email }}

------------------------------------------------------------------*/

angular.module('ADE').filter('email', ['$filter',function($filter) {

	return function(input) {
		if(!input) return '';
		if(angular.isArray(input)) input = input[0];
		if(!angular.isString(input)) return input+"";

		return $filter('linky')(input);
	};
}]);


/* ==================================================================
AngularJS Datatype Editor - Icon
A directive to choose an icon from a list of many bootstrap icons
Specify the allowed icons in ade.js

Usage:
<a ade-icon ng-model="data"></a>

Config:

ade-id:
	If this id is set, it will be used in messages broadcast to the app on state changes.
ade-readonly:
	If you don't want the icon to be editable	

To use different icons, adjust the array in ade.js

Messages:
	name: ADE-start
	data: id from config

	name: ADE-finish
	data: {id from config, old value, new value, exit value}

 Messages:
 name: ADE-start
 data: id from config

 name: ADE-finish
 data: {id from config, old value, new value}

 ------------------------------------------------------------------*/

angular.module('ADE').directive('adeIcon', ['ADE', '$compile', '$filter', function(ADE, $compile, $filter) {
	//TODO: Shouldnt this be in a compile block? It seems to work
	var len = ADE.icons.length;
	var iconsPopupTemplate = '';
	var s = 0;

	if (len > 0) iconsPopupTemplate = '<a class="ade-clear">clear</a>';
	for (var i = 0; i < len; i++) {
		iconsPopupTemplate += '<span class="ade-icon icon-' + ADE.icons[i] + '"></span>';
	}

	return {
		require: '?ngModel', //optional dependency for ngModel
		restrict: 'A', //Attribute declaration eg: <div ade-icon=""></div>

		scope: {
			adeId: "@",
			adeReadonly: "@",
			ngModel: "="
		},

		//The link step (after compile)
		link: function(scope, element, attrs) {
			
			var editing = false;
			var exit = 0; //0=click, 1=tab, -1= shift tab, 2=return, -2=shift return, 3=esc. controls if you exited the field so you can focus the next field if appropriate
			var input = null; //a reference to the invisible input DOM object
			var timeout = null; //the timeout for when clicks cause a blur of the popup's invisible input
			var readonly = false;
			var stopObserving = null;
			var adeId = scope.adeId;

			if(scope.adeReadonly!==undefined && scope.adeReadonly=="1") readonly = true;

			var makeHTML = function() {
				var html = $filter('icon')(scope.ngModel);
				element.html(html);
			};

			var saveEdit = function(exited, newValue) {				
				//we are saving, so cancel any delayed blur saves that we might get
				window.clearTimeout(timeout);

				var oldValue = scope.ngModel;
				var value = newValue || oldValue;
				exit = exited;

				if (exit !== 3) { //don't save value on esc
					scope.ngModel = value;
				}
				editing = false;

				destroy();

				ADE.done(adeId, oldValue, scope.ngModel, exit);

				if (exit == 1) {
					element.data('dontclick', true); //tells the focus handler not to click
					element.focus();
					//TODO: would prefer to advance the focus to the next logical element on the page
				} else if (exit == -1) {
					element.data('dontclick', true); //tells the focus handler not to click
					element.focus();
					//TODO: would prefer to advance the focus to the previous logical element on the page
				}
			};

			//place the popup in the proper place on the screen
			var place = function() {
				ADE.place('.'+ADE.popupClass,element);
			};

			//turns off all event listeners on the icons
			var stopListening = function() {	
				var nextElement = element.next('.ade-popup');
				var clearNode = nextElement.find('.ade-clear');
				var iconNode = nextElement.find('span');

				if(clearNode) clearNode.off();
				if(iconNode) iconNode.off();
			};

			var clickHandler = function(e) {
				//Hide any that are already up
				var iconBox = $('.'+ADE.popupClass);
				if(iconBox.length) {
					$(document).trigger('ADE_hidepops.ADE');
				}

				element.off('keypress.ADE');

				e.preventDefault();
				e.stopPropagation();

				adeId = scope.adeId;
				ADE.begin(adeId);

				var iconPopup = angular.element('.' + ADE.popupClass);
				var clickTarget = angular.element(e.target);
				var attrClass = clickTarget.attr('class');

				var isMySpan = (angular.isDefined(attrClass) && attrClass.match('icon')!==null && attrClass.match('icon').length && clickTarget.parent()[0] == element[0]);
				var isMyDiv = (clickTarget[0]==element[0]);

				if ((isMySpan || isMyDiv)  && (!iconPopup || !iconPopup.length)) {   //don't popup a second one
					editing = true;
					$compile('<div class="' + ADE.popupClass + ' ade-icons dropdown-menu open"><h4>Select an Icon</h4>' + iconsPopupTemplate + '<div class="ade-hidden"><input id="invisicon" type="text" /></div></div>')(scope).insertAfter(element);
					place();

					input = angular.element('#invisicon');
					
					var nextElement = element.next('.ade-popup');
					var clearNode = nextElement.find('.ade-clear');
					var iconNode = nextElement.find('span');

					clearNode.on('click.ADE', function() {
						scope.$apply(function() {
							saveEdit(0, 'ban');
						});
					});

					//handles click on an icon inside a popup
					angular.forEach(iconNode, function(el) {
						var node = angular.element(el);
						node.on('click.ADE', function() {
							window.clearTimeout(timeout); 
							var iconClass =  node.attr('class'); //gets what you clicked on by class name

							if (iconClass.match('ade-icon')) { //makes sure we clicked
								var classes = iconClass.split(" ");// grab the last class which is what we are about
								var iconType = classes.pop().substring(5);
								scope.$apply(function() {
									saveEdit(0, iconType);
								});
							}
						});

					});

					if(ADE.keyboardEdit) input.focus();

					ADE.setupKeys(input, saveEdit, false, scope);

					// TODO: handle keyboard inputs to change icons
					// input.bind('keydown.ADE', function(e) {
					// 	if(e.keyCode==37) { //left
					// 		e.preventDefault();
					// 		e.stopPropagation();
					// 	} else if(e.keyCode==39) { //right
					// 		e.preventDefault();
					// 		e.stopPropagation();
					// 	}
					// });

					//handles blurs of the invisible input.  This is done to respond to clicks outside the popup
					input.on('blur.ADE', function(e) {
						//We delay the closure of the popup to give the internal icons a chance to
						//fire their click handlers and change the value.
						timeout = window.setTimeout(function() {
							scope.$apply(function() {
								saveEdit(0);
							});
						},500);
					});

					ADE.setupScrollEvents(element,function() {
						scope.$apply(function() {
							place();
						});
					});

					$(document).on('ADE_hidepops.ADE',function() {
						saveEdit(3);
					});

					ADE.setupTouchBlur(input);
				}
			};

			var focusHandler = function(e) {
				//if this is an organic focus, then do a click to make the popup appear.
				//if this was a focus caused by myself then don't do the click
				if (!element.data('dontclick')) {
					clickHandler(e);
					return;
				}
				window.setTimeout(function() { //IE needs this delay because it fires 2 focus events in quick succession.
					element.data('dontclick',false);
				},100);

				//listen for keys pressed while the element is focused but not clicked
				element.on('keypress.ADE', function(e) {
					var keyCode = (e.keyCode ? e.keyCode : e.which); //firefox doesn't register keyCode on keypress only on keyup and down

					if (keyCode == 13) { //return
						e.preventDefault();
						e.stopPropagation(); //to prevent return key from going into text box
						element.click();
					}
				});
			};

			//handles blur events
			element.on('blur.ADE', function(e) {
				element.off('keypress.ADE');
			});

			//setup editing events
			if(!readonly) {
				element.on('click.ADE', function(e) { 
					//scope.$apply(function() { 
						clickHandler(e); //not necessary?
					//});
				});

				element.on('focus.ADE', function(e) {
					focusHandler(e);
				});
			}

			 //A callback to observe for changes to the id and save edit
			//The model will still be connected, so it is safe, but don't want to cause problems
			var observeID = function(value) {
				 //this gets called even when the value hasn't changed, 
				 //so we need to check for changes ourselves
				 if(editing && adeId!==value) saveEdit(3);
			};

			//If ID changes during edit, something bad happened. No longer editing the right thing. Cancel
			stopObserving = attrs.$observe('adeId', observeID);

			var destroy = function() { 
				ADE.teardownScrollEvents(element);
				ADE.hidePopup();
				ADE.teardownBlur(input);
				if(input) input.off();
				stopListening();
				$(document).off('ADE_hidepops.ADE');
			};

			//need to clean up the event watchers when the scope is destroyed
			scope.$on('$destroy', function() {
				destroy();
				if(element) element.off('.ADE');
				if(stopObserving && stopObserving!=observeID) { //Angualar <=1.2 returns callback, not deregister fn
					stopObserving();
					stopObserving = null;
				} else {
					delete attrs.$$observers['adeId'];
				}
			});

			//need to watch the model for changes
			scope.$watch(function(scope) {
				return scope.ngModel;
			}, function () {
				makeHTML();
			});
		}
	};
}]);

/* ==================================================================
	AngularJS Datatype Editor - Icon
	A filter to display a bootstrap icon (or any icon with a css name)
    Specify the allowed icons in ade.js

	Usage:
	{{ data | icon:'star' }}

------------------------------------------------------------------*/

angular.module('ADE').filter('icon', ['ADE', function(ADE) {
	return function(input, option) {
        if (angular.isArray(input)) input = input[0];
        
		if (!input) input = 'ban-circle';
        var matchFound = false;
        var iconsLength = ADE.icons.length;

        for (var i = 0; i < iconsLength; i++) {
            if (input === ADE.icons[i]) {
                matchFound = true;
                break;
            }
        }
        if (!matchFound) input = 'ban-circle';

        return '<span class="ade-icon icon-' + input + '">';
	};
}]);

/* ==================================================================
	AngularJS Datatype Editor - Integer
	A filter to display a number as an integer.
	Wrapper for Angular's built in filter so that we can display
	invalid inputs correctly.

	Usage:
	{{ data | integer }}

------------------------------------------------------------------*/

angular.module('ADE').filter('integer', ['$filter',function($filter) {

	return function(input) {
		var output = '';

		if (angular.isArray(input)) input = input[0];
		if (angular.isString(input)) input = parseFloat(input);
		if (angular.isUndefined(input) || !angular.isNumber(input)) return output;

		output = $filter('number')(input,0);

		return output;
	 };
}]);


/* ==================================================================
	AngularJS Datatype Editor - Integer
	A filter to display a number as an integer.
	Wrapper for Angular's built in filter so that we can display
	invalid inputs correctly.

	Usage:
	{{ data | integer }}

------------------------------------------------------------------*/

angular.module('ADE').filter('flexnum', ['$filter',function($filter) {

	return function(input) {
		var output = '';

		if (angular.isArray(input)) input = input[0];
		if (angular.isString(input)) input = parseFloat(input);
		if (angular.isUndefined(input) || !angular.isNumber(input)) return output;

		output = $filter('number')(input);

		return output;
	 };
}]);


/* ==================================================================
	AngularJS Datatype Editor - Duration
	A directive to edit a duration field in place

	Usage:
	<div ade-duration ade-id='1234' ade-class="myClass" ng-model="data"></div>

	Config:

	ade-id:
		If this id is set, it will be used in messages broadcast to the app on state changes.
	ade-class:
		A custom class to give to the input
	ade-readonly:
		If you don't want the stars to be editable	

	Messages:
		name: ADE-start
		data: id from config

		name: ADE-finish
		data: {id from config, old value, new value, exit value}

------------------------------------------------------------------*/

angular.module('ADE').directive('adeDuration', ['ADE', '$compile', '$filter', function(ADE, $compile,$filter) {
	return {
		require: '?ngModel', //optional dependency for ngModel
		restrict: 'A', //Attribute declaration eg: <div ade-duration></div>

		scope: {
			adeId: "@",
			adeClass: "@",
			adeReadonly: "@",
			ngModel: "="
		},

		//The link step (after compile)
		link: function(scope, element, attrs) {
			var editing=false; //are we in edit mode or not
			var input = null; //a reference to the input DOM object
			var exit = 0; //0=click, 1=tab, -1= shift tab, 2=return, -2=shift return, 3=esc. controls if you exited the field so you can focus the next field if appropriate
			var readonly = false;
			var inputClass = "";
			var stopObserving = null;
			var adeId = scope.adeId;

			if(scope.adeClass!==undefined) inputClass = scope.adeClass;
			if(scope.adeReadonly!==undefined && scope.adeReadonly=="1") readonly = true;

			var makeHTML = function() {
				var html = "";
				var value = scope.ngModel;
				
				if(value!==undefined) {
					html = $filter('duration')(value); 
				}

				element.html(html);
			};

			//called once the edit is done, so we can save the new data	and remove edit mode
			var saveEdit = function(exited) {
				var oldValue = scope.ngModel;
				exit = exited;

				if(exited!=3) { //don't save value on esc
					scope.ngModel = input.val();
				}

				element.show();
				input.remove();
				editing=false;

				ADE.done(adeId, oldValue, scope.ngModel, exit);
				ADE.teardownBlur(input);
				ADE.teardownKeys(input);
			};
			
			var clickHandler = function() {
				if(editing) return;
				editing=true;
				exit = 0;
				
				var value = $filter('duration')(scope.ngModel);

				adeId = scope.adeId;
				ADE.begin(adeId);

				element.hide();
				$compile('<input type="text" class="ade-input '+inputClass+'" value="'+value+'" />')(scope).insertAfter(element);
				input = element.next('input');
				input.focus();
				
				//put cursor at end
				input[0].selectionStart = input[0].selectionEnd = input.val().length; 

				ADE.setupBlur(input,saveEdit,scope);
				ADE.setupKeys(input,saveEdit,false,scope);
			};

			//setup events
			if(!readonly) {
				element.on('click.ADE', function(e) {
					scope.$apply(function() {
						clickHandler(e);
					})
				});
			}

			//A callback to observe for changes to the id and save edit
			//The model will still be connected, so it is safe, but don't want to cause problems
			var observeID = function(value) {
				 //this gets called even when the value hasn't changed, 
				 //so we need to check for changes ourselves
				 if(editing && adeId!==value) saveEdit(3);
			};

			//If ID changes during edit, something bad happened. No longer editing the right thing. Cancel
			stopObserving = attrs.$observe('adeId', observeID);

			scope.$on('$destroy', function() { //need to clean up the event watchers when the scope is destroyed
				if(element) element.off('click.ADE');

				if(stopObserving && stopObserving!=observeID) { //Angualar <=1.2 returns callback, not deregister fn
					stopObserving();
					stopObserving = null;
				} else {
					delete attrs.$$observers['adeId'];
				}
			});

			//need to watch the model for changes
			scope.$watch(function(scope) {
				return scope.ngModel;
			}, function () {
				makeHTML();
			});

		}
	};
}]);
/* ==================================================================
	AngularJS Datatype Editor - Duration
	A filter to display a number that represents minutes, and format it
	into a pretty version, such as "2hrs".

	Usage:
	{{ data | duration }}

------------------------------------------------------------------*/

angular.module('ADE').filter('duration', function() {

	//Minutes are passed in and a more readable (hrs mins) string is returned
	function mins2Pretty(value) {
		// value should be passed in minutes
		var output = '';
		var hours = 0;
		var mod = 0;

		if(value < 60 && value > 0) {
			output = (value === 1) ? value + 'min' : value + 'mins';
		} else if (value >= 60){
			mod = value % 60;
			hours = Math.round((value-mod) / 60);
			output =  (hours === 1) ? hours + 'hr': hours + 'hrs';

			if (mod > 0 ) {
				output += (mod === 1) ? ' ' + mod + 'min': ' ' + mod + 'mins';
			}
		} else { //catching negative values
			output = '';
		}

		return output;
	}

	//Duration was specified as a single unit (1hr or 60min). Return minutes
	function single2Mins(value) {
		var clean = parseFloat(value, 10);
		if((value.indexOf('h') !== -1)) clean = clean*60;
		return Math.round(clean);
	}

	//Duration was specified as two units (1hrs 90mins). Return minutes
	function double2Mins(value) {
		var values = value.split(' ');
		return parseFloat(values[0],10)*60+parseFloat(values[1],10);
	}

	return function(input) {
		if(!input) return '';
		if (angular.isArray(input)) input = input[0];
		
		var output = '';

		//if it is already a number, just prettify it
		if (!isNaN(input)) return mins2Pretty(input);
		if(!angular.isString(input)) return '';
		
		input = input.replace(" h","h").replace(" m","m");

		var values = input.split(' ');
		switch(values.length) {
			case 1: //only one number specified (1hr or 60min)
				output = single2Mins(input);
				output = mins2Pretty(output);
				break;
			case 2: //two units (1hrs 90mins)
				output = double2Mins(input);
				output = mins2Pretty(output);
				break;
			default:
				output = '';
		}

		return output;
	};
});
/* ==================================================================
AngularJS Datatype Editor - List
A directive to pick a single value from a list or add a new value

This directive uses a modified version of ngTagsInput
http://mbenford.github.io/ngTagsInput

You will need to include ngTagsInput as a dependency to your app

Usage:
<div ade-list="list1" ade-id="123" ade-query="query(val,listId)" ng-model="data"></div>

Config:

ade-list:
	The id number for the type of list. If you have multiple lists per page, this will
	distinguish between them
ade-id:
	If this id is set, it will be used in messages broadcast to the app on state changes.
ade-readonly:
	If you don't want the list to be editable	
ade-query:
	A function in your controller that will provide matches for search query.
	The argument names need to match

 Messages:
 name: ADE-start
 data: id from config

 name: ADE-finish
 data: {id from config, old value, new value, exit value}

 ------------------------------------------------------------------*/

angular.module('ADE').directive('adeList', 
 ['ADE', '$compile', '$filter', '$sanitize', 
 function(ADE, $compile, $filter, $sanitize) {
	return {
		require: '?ngModel', //optional dependency for ngModel
		restrict: 'A', //Attribute declaration eg: <div ade-toggle=""></div>

		scope: {
			adeList: "@",
			adeId: "@",
			adeClass: "@",
			adeQuery: "&",
			adeReadonly: "@",
			ngModel: "="
		},

		//The link step (after compile)
		link: function(scope, element, attrs) {
			var editing = false; //are we in edit mode or not
			var input = null; //a reference to the input DOM object
			var readonly = false;
			var exit = 0; //0=click, 1=tab, -1= shift tab, 2=return, -2=shift return, 3=esc. controls if you exited the field so you can focus the next field if appropriate
			var stopObserving = null;
			var adeId = scope.adeId;

			if(scope.adeReadonly!==undefined && scope.adeReadonly=="1") readonly = true;

			scope.query = function(val) { //called by ng-tags-input on each keystroke to get the autocomplete
				return scope.adeQuery({val:val, listId: scope.adeList});
			};
			scope.esc = function() { //called by ng-tags-input when esc key is pressed 
				destroy();
				ADE.done(adeId, scope.ngModel, scope.ngModel, 3);
			};
			scope.ret = function(e) {
				var exit = e.shiftKey ? -2 : 2;
				saveEdit(exit);
			};
			scope.tab = function(e) {
				var exit = e.shiftKey ? -1 : 1;
				saveEdit(exit);
			};
			scope.blurred = function(how) {
				saveEdit(how);
			};
			scope.addTag = function() {
				scope.tags = scope.tags.slice(-1);
			}

			//generates HTML for the star
			var makeHTML = function() {
				var html = "";

				if (scope.ngModel!==undefined) {
					if (angular.isString(scope.ngModel)) {
						html = scope.ngModel;
					} else if (angular.isArray(scope.ngModel)) {
						var html = '';
						$.each(scope.ngModel, function(i, v) {
							if (html) html += ', ';
							html += v;
						});
					}
				}
				html = $sanitize(html).replace(/<[^>]+>/gm, '');
				element.html(html);
			}

			//called once the edit is done, so we can save the new data and remove edit mode
			var saveEdit = function(exited) {
				var oldValue = scope.ngModel;
				exit = exited;

				if (exited != 3) { //don't save value on esc
					var value = scope.tags;
					if (angular.isArray(value)) {
						if(value[0] && value[0].text) value = value[0].text
						else value = null;
					} else if (angular.isObject(value) && value.text) {
						if(value.text) value = value.text;
						else value = null;
					} else {
						value = (value) ? value.text : null;
					}

					scope.ngModel = value;
				}

				destroy();

				ADE.done(adeId, oldValue, scope.ngModel, exit);
			};


			var clickHandler = function(e) {
				if (editing) return;
				editing = true;
				exit = 0;

				adeId = scope.adeId;
				ADE.begin(adeId);
				element.hide();


				var listId = '';
				if (scope.adeList) listId = scope.adeList; //data that is passed through to the query function

				var autocomplete = "query($query)";

				scope.tags = angular.copy(scope.ngModel);
				if (angular.isString(scope.tags)) scope.tags = scope.tags.split(',');

				var html = '<tags-input class="ade-list-input" ng-model="tags" min-length="1" on-tag-added="addTag()" replace-spaces-with-dashes="false" enable-editing-last-tag="true" on-esc-key="esc()" on-ret-key="ret(e)" on-blurred="blurred(how)" placeholder="..."><auto-complete source="'+autocomplete+'" min-length="1" load-on-empty="true" load-on-focus="true"></auto-complete></tags-input>';
				$compile(html)(scope).insertAfter(element);

				$('.ade-list-input').on("keydown",function(e) { //prevent tab key from doing default behavior
					if (e.keyCode == 9) { //tab
						e.preventDefault();
						e.stopPropagation();
						input.blur();
					}
				});

				setTimeout(function() {
					input = $('.ade-list-input .tag-list + input');
					input.focus();
					ADE.setupTouchBlur(input);
				},100); //tag input needs little time to initialize before it can accept a focus

			};

			var focusHandler = function(e) {
				element.on('keypress.ADE', function(e) {
					if (e.keyCode == 13) { //return
						e.preventDefault();
						e.stopPropagation();
						element.click();
					}
				});
			};
			
			//setup events
			if(!readonly) {
				element.on('click.ADE', function(e) {
					scope.$apply(function() {
						clickHandler(e);
					})
				});
				element.on('focus.ADE',  function(e) {
					scope.$apply(function() {
						focusHandler(e);
					})
				});
				element.on('blur.ADE', function(e) {
					element.off('keypress.ADE');
				});
			}


			//A callback to observe for changes to the id and save edit
			//The model will still be connected, so it is safe, but don't want to cause problems
			var observeID = function(value) {
				 //this gets called even when the value hasn't changed, 
				 //so we need to check for changes ourselves
				 if(editing && adeId!==value) saveEdit(3);
			};

			//If ID changes during edit, something bad happened. No longer editing the right thing. Cancel
			stopObserving = attrs.$observe('adeId', observeID);

			var destroy = function() {
				element.show();

				if(input) input.off();
				$('.ade-list-input').off();
				$('.ade-list-input').remove();

				ADE.teardownBlur();

				editing = false;
			};

			scope.$on('$destroy', function() { //need to clean up the event watchers when the scope is destroyed
				destroy();

				if(element) {
					element.off('click.ADE');
					element.off('focus.ADE');
					element.off('blur.ADE');
					element.off('keypress.ADE');
				}

				if(stopObserving && stopObserving!=observeID) { //Angualar <=1.2 returns callback, not deregister fn
					stopObserving();
					stopObserving = null;
				} else {
					delete attrs.$$observers['adeId'];
				}
			});
			
			//need to watch the model for changes
			scope.$watch(function(scope) {
				return scope.ngModel;
			}, function () {
				makeHTML();
			});

		}
	};
}]);
/* ==================================================================
	AngularJS Datatype Editor - Rich Text
	A directive to edit a large text blob in place.
	TODO: In the future it will allow rich text formatting

	Usage:
	<div ade-rich ade-class="input-large" ade-id="1234" ade-max="2000" ade-cut="25" ng-model="data"></div>

	Config:

	ade-id:
		If this id is set, it will be used in messages broadcast to the app on state changes.
	ade-class:
		A custom class to give to the input
	ade-readonly:
		If you don't want the stars to be editable	
	ade-max:
		The optional maximum length to enforce
	ade-cut:
		The number of characters to show as a preview before cutting off and showing
		the rest after a click or hover	

	Messages:
		name: ADE-start
		data: id from config

		name: ADE-finish
		data: {id from config, old value, new value, exit value}

------------------------------------------------------------------*/

angular.module('ADE').directive('adeRich', ['ADE', '$compile', '$sanitize', function(ADE, $compile, $sanitize) {
	return {
		require: '?ngModel', //optional dependency for ngModel
		restrict: 'A', //Attribute declaration eg: <div ade-rich=""></div>

		scope: {
			adeId: "@",
			adeClass: "@",
			adeReadonly: "@",
			adeMax: "@",
			adeCut: "@",
			ngModel: "="
		},

		//The link step (after compile)
		link: function(scope, element, attrs) {
			// each tinyMCE editor get its own id
			// this is not needed but makes it clearer that were dealing with separate editors
			var id = Math.floor(Math.random() * 100000);
			var editing = false;
			var txtArea = null;
			var input = null;
			var exit = 0; //0=click, 1=tab, -1= shift tab, 2=return, -2=shift return, 3=esc. controls if you exited the field so you can focus the next field if appropriate
			var timeout = null; //the delay when mousing out of the ppopup
			var readonly = false;
			var inputClass = "";
			var cutLength = 100; 
			var maxLength = null; //the maxLength is enforced on edit, not from external changes
			var origMaxLength = null;
			var stopObserving = null;
			var adeId = scope.adeId;
			var supportsTouch = ('ontouchend' in window);
			var iOS = ( navigator.userAgent.match(/(iPad|iPhone|iPod)/g) ? true : false );
			var windowW = $(window).width();

			if(scope.adeMax!==undefined) origMaxLength = maxLength = parseInt(scope.adeMax);
			if(scope.adeClass!==undefined) inputClass = scope.adeClass;
			if(scope.adeReadonly!==undefined && scope.adeReadonly=="1") readonly = true;
			if(scope.adeCut!==undefined) cutLength = parseInt(scope.adeCut);

			//Whenever the model changes we need to regenerate the HTML for displaying it
			var makeHTML = function() {
				var html = "";
				var value = scope.ngModel;
				var len = cutLength || 100;
				
				if (value!==undefined) {
					if (angular.isArray(value)) value = value[0];

					if(value==null || value==undefined) value = "";
					if (!value.split) value = value.toString(); //convert to string if not string (to prevent split==undefined)

					//set the max length higher or it would be truncated right away on editing
					if(maxLength && value.length>maxLength) maxLength = value.length;
		
					// strip html
					value = $sanitize(value).replace(/<[^>]+>/gm, '');

					var lines = value.split(/\r?\n|\r/);
					value = lines[0]; //get first line

					if (len < value.length) {
						html = value.substring(0, len) + '...';
					} else if(lines.length>1) {
						html = value + "...";
					} else {
						html = value;
					}
				}

				element.html(html);
			};

			//called once the edit is done, so we can save the new data	and remove edit mode
			var saveEdit = function(exited) {
				var oldValue = scope.ngModel;
				exit = exited;
						
				var editor = $('#tinyText' + id + '_ifr').contents().find('#tinymce')[0];
				var currentLength = $(editor).text().length;

				// don't save value on esc (revert)
				// and if the current length is greater than the previous max length
				// 100 padding covers html tags
				if ((exited != 3) && (!maxLength || (currentLength <= maxLength))) {
					// Special case: Length surpasses maxLength and maxLength is artificially high
					// Reduce maxLength to current length until it reaches origMaxLength
					if (maxLength > origMaxLength && maxLength>currentLength) {
							maxLength = currentLength;
					}

					if(editor!=undefined) { //if we can't find the editor, dont overwrite the old text with nothing. Just cancel
						var value = editor.innerHTML;
						// check if contents are empty
						if (value === '<p><br data-mce-bogus="1"></p>' || value === '<p></p>' || value === '<p><br></p>') {
							value = '';
						}
						value = $.trim(value);
						scope.ngModel = value;
					} else {
						//editor wasn't found for some reason. Can we recover, or do we need to?
					}
				}

				input.off();

				input.remove();
				editing = false;

				ADE.hidePopup(element);
				ADE.done(adeId, oldValue, scope.ngModel, exit);

				if (exit == 1) {
					element.data('dontclick', true); //tells the focus handler not to click
					element.focus();
					//TODO: would prefer to advance the focus to the next logical element on the page
				} else if (exit == -1) {
					element.data('dontclick', true); //tells the focus handler not to click
					element.focus();
					//TODO: would prefer to advance the focus to the previous logical element on the page
				}

				// we're done, no need to listen to events
				destroy();
				setupElementEvents();
			};

			//shows a popup with the full text in read mode
			//TODO: handle scrolling of very long text blobs
			var viewRichText = function() {
				ADE.hidePopup();

				var content = scope.ngModel; //what is inside the popup

				if(scope.ngModel && angular.isString(scope.ngModel)) content = scope.ngModel.replace(/\n/g, '<br />');

				if (!content) return; //dont show popup if there is nothing to show

				$compile('<div class="ade-popup ade-rich dropdown-menu open"><div class="ade-richview">' + content + '</div></div>')(scope).insertAfter(element);
				place();

				// Convert relative urls to absolute urls
				// http://aknosis.com/2011/07/17/using-jquery-to-rewrite-relative-urls-to-absolute-urls-revisited/
				$('.ade-richview').find('a').not('[href^="http"],[href^="https"],[href^="mailto:"],[href^="#"]').each(function() {
					var href = this.getAttribute('href');
					var hrefType = href.indexOf('@') !== -1 ? 'mailto:' : 'http://';
					this.setAttribute('href', hrefType + href);
				});

				editing = false;

				input = element.next('.ade-rich');
				input.on('mouseenter.ADE', mousein); //these two are to debounce the mouse leaving/entering
				input.on('mouseleave.ADE', mouseout);
				if(!readonly) input.on('click.ADE', mouseclick);

				$(document).on('touchend.ADE', function(e) {
					var outerClick = $('.ade-popup').has(e.target).length === 0;
					if(outerClick) mouseout();
				});
				
				//when we scroll, should try to reposition because it may
				//go off the bottom/top and we may want to flip it
				//TODO; If it goes off the screen, should we dismiss it?
				$(document).on('scroll.ADE',function() {
					scope.$apply(function() {
						place();
					}); 
				});

				//when the window resizes, we may need to reposition the popup
				$(window).on('resize.ADE',function() {
					scope.$apply(function() {
						place();
					}); 
				});
			};

			//place the popup in the proper place on the screen by flipping it if necessary
			var place = function() {
				if(windowW<=480 && editing) return;
				ADE.place('.ade-rich',element,25,-5);
			};

			//sets the height of the textarea based on the actual height of the contents.
			//min and max are set in css
			var textareaHeight = function(elem) {
				elem.style.height = '1px';
				elem.style.height = (elem.scrollHeight) + 'px';
			};

			// detect clicks outside tinymce textarea
			var outerBlur = function(e) {
				// check where click occurred
				//   1: inside ade popup
				//   0: outside ade popup
				var outerClick = $('.ade-popup').has(e.target).length === 0;

				// check if modal for link is shown
				var modalShown = $('.mce-floatpanel').css('display') === 'block';
				
				if (!modalShown && outerClick) {
					// some elements are outside popup but belong to mce
					// these elements start with the text 'mce_' or have a parent/grandparent that starts with the text 'mce_'
					// the latter include texcolor color pickup background element, link ok and cancel buttons
					
					// check if id starts with 'mce_'
					//   0: true
					//  -1: false
					var parent = e.target;
					var startsMce = false;
					while (parent) {
						if (parent.id.search('mce_') === 0) {
							startsMce = true;
							break;
						}
						parent = parent.parentElement;
					}

					// blur and save changes
					if (!startsMce) {
						saveEdit(0);
					}
				}
			};

			// handle special keyboard events
			var handleKeyEvents = function(e) {
				// Enforce maximum length, if defined

				// http://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes
				// Esc - 27; Tab - 9; Backspace - 8 ; Delete - 46; Arrow keys = 37-40
				var specialCodes = [27, 9, 8, 46, 37, 38, 39, 40];

				// Do not enforce on special codes
				if (maxLength && specialCodes.indexOf(e.keyCode) == -1) {
					var editor = $('#tinyText' + id + '_ifr').contents().find('#tinymce')[0];
					var editorValue = editor.innerHTML;
					var length = $(editor).text().length;

					// Don't allow more characters
					if (length >= maxLength) {
						e.stopPropagation();
						e.preventDefault();
					}
				}

				// Listen for esc and tab events
				switch(e.keyCode) {
					case 27: // esc
						scope.$apply(function() {
							saveEdit(3); // don't save results
						});
						e.preventDefault();
						$(document).off('click.ADE');
						break;
					case 9: // tab
						var exit = e.shiftKey ? -1 : 1;
						scope.$apply(function() {
							saveEdit(exit); // blur and save
						});
						e.preventDefault();
						$(document).off('click.ADE');
						break;
					default:
						break;
				}
			};

			//enters edit mode for the text
			var editRichText = function() {
				window.clearTimeout(timeout);
				if(input) input.off('.ADE');
				element.off('.ADE');
				destroy();

				ADE.hidePopup(element);

				var modelValue = "";
				if(scope.ngModel) modelValue = scope.ngModel;

				var touchClass="";
//				if(supportsTouch) touchClass = " ade-hasTouch"; //because touch devices (iOS) put copy/paste controls that would cover the rich text toolbar

				var content = '<textarea id="tinyText' + id + '" class="' + inputClass + '" style="height:30px">' + modelValue + '</textarea>';
				
				var html = '<div class="ade-popup ade-rich dropdown-menu open '+ touchClass + '">' + content + '</div>';
				$compile(html)(scope).insertAfter(element);
				place();

				// Initialize tinymce
				// Full example:
				// http://www.tinymce.com/tryit/full.php
				tinymce.init({
					selector: "#tinyText" + id,
					theme: "modern",
					menubar: "false",
					plugins: ["textcolor", "link", 'fullscreen'],
					toolbar: "saveButton | cancelButton | styleselect | bold italic | forecolor backcolor | bullist numlist | outdent indent | link",
					baseURL: "",
					setup: function(ed) {
						ed.on('init', function(args) {
							//go fullscreen on small windows
							if(windowW<=480) tinymce.execCommand('mceFullScreen');

							//focus the text area. In a timer to allow tinymce to initialize.
							tinymce.execCommand('mceFocus',false,"tinyText" + id);
						});
						ed.on('keydown', handleKeyEvents);
						ed.addButton('saveButton', {
							title: "Save",
							text: "Save",
							icon:false,
							onclick: function() {
								scope.$apply(function() {
									saveEdit(0); // blur and save
								});
							}
						});
						ed.addButton('cancelButton', {
							title: "Cancel",
							text: "Cancel",
							icon:false,
							onclick: function() {
								scope.$apply(function() {
									saveEdit(3); // blur and cancel
								});
							}
						});
					}
				});

				editing = true;

				input = element.next('.ade-rich');

				// save when user blurs out of text editor
				// listen to clicks on all elements on page
				// in a timer to prevent clicks on read popup from bleeding through
				setTimeout(function() {
					/* Note: Adding any touch event listener (touchend, touchstart) cause iOS to 
						delay the placement of the cursor on tap and instead requires
						a tap+hold to place cursor. We need the touch event to save on an
						external tap (document.click isn't called on ios). 
						Can't find a way around this.
					*/
					$(document).on('click.ADE touchend.ADE', function(e) {
						scope.$apply(function() {
							outerBlur(e);
						});
					});					
				});

				//when we scroll, should try to reposition because it may
				//go off the bottom/top and we may want to flip it
				//TODO; If it goes off the screen, should we dismiss it?
				$(document).on('scroll.ADE',function() {
					scope.$apply(function() {
						place();
					}); 
				});

				//when the window resizes, we may need to reposition the popup
				$(window).on('resize.ADE',function() {
					scope.$apply(function() {
						place();
					}); 
				});
			};

			//When the mouse enters, show the popup view of the note
			var mousein = function()  {
				window.clearTimeout(timeout);
				
				//if any other popup is open in edit mode, don't do this view
				if (angular.element('.ade-rich').hasClass('open') && angular.element('.ade-rich').find('textarea').length) return;

				var linkPopup = element.next('.ade-rich');
				if (!linkPopup.length) {
					viewRichText();
				}
			};

			//if the mouse leaves, hide the popup note view if in read mode
			var mouseout = function() {				
				var linkPopup = element.next('.ade-popup');
				if (linkPopup.length && !editing) { //checks for read/edit mode
					timeout = window.setTimeout(function() {
						if(input) input.off('.ADE');
						ADE.hidePopup(element);
						destroy();
					},400);
				}
			};

			//handles clicks on the read version of the data
			var mouseclick = function() {
				window.clearTimeout(timeout);
				if (editing) return;
				editing = true;
				exit = 0;

				adeId = scope.adeId;
				ADE.begin(adeId);

				editRichText();
				setTimeout(place); //needs to be in a timeout for the popup's height to be calculated correctly
			};

			//sets up click, mouse enter and mouse leave events on the original element for preview and edit
			var setupElementEvents = function() {
				element.on('mouseenter.ADE', mousein);
				element.on('mouseleave.ADE', mouseout);
				
				if(!readonly) {
					element.on('click.ADE', mouseclick);

					//handles enter keydown on the read version of the data
					element.on('keydown.ADE', function(e) {
						if (e.keyCode === 13) { // enter
							mouseclick();
						}
					});
				}
			};

			setupElementEvents();

			//A callback to observe for changes to the id and save edit
			//The model will still be connected, so it is safe, but don't want to cause problems
			var observeID = function(value) {
				 //this gets called even when the value hasn't changed, 
				 //so we need to check for changes ourselves
				 if(editing && adeId!==value) saveEdit(3);
				 else if(adeId!==value) ADE.hidePopup(element);
			};

			//If ID changes during edit, something bad happened. No longer editing the right thing. Cancel
			stopObserving = attrs.$observe('adeId', observeID);

			var destroy = function() {
				$(document).off('click.ADE');
				$(document).off('touchend.ADE');
				$(document).off('scroll.ADE');
				$(window).off('resize.ADE');
			};

			scope.$on('$destroy', function() { //need to clean up the event watchers when the scope is destroyed
				destroy();

				if(element) element.off();
				if(input) input.off();

				if(stopObserving && stopObserving!=observeID) { //Angualar <=1.2 returns callback, not deregister fn
					stopObserving();
					stopObserving = null;
				} else {
					delete attrs.$$observers['adeId'];
				}
			});

			//need to watch the model for changes
			scope.$watch(function(scope) {
				return scope.ngModel;
			}, function () {
				makeHTML();
			});

		}
	};
}]);

/* ==================================================================
	AngularJS Datatype Editor - Money
	A filter to display a number as a currency.  This wraps Angular's
	native currency filter so that we can properly handly invalid
	inputs.

	Usage:
	{{ data | money }}

------------------------------------------------------------------*/

angular.module('ADE').filter('money', ['$filter',function($filter) {
	return function(input) {
		var output = '';
		var clean;

		if (angular.isUndefined(input)) return output;
		if (angular.isArray(input)) input = input[0];

		if (angular.isString(input)) {
			input= input.replace('(','-').replace(')',''); //parens turn into negative number
			input = parseFloat(input.replace(/[$]/g, ''));
		}

		if (angular.isNumber(input)) {
			clean = parseFloat(input);
			output = (clean !== 0) ? $filter('currency')(clean) : output;
		}

		return output;
	};
}]);


/* ==================================================================
 AngularJS Datatype Editor - Multi-state 
 A directive to toggle an icon between N states

 Usage:
 <a ade-multi ade-id="1234" ade-classes="['ade-unstar','ade-star''ade-superstar']" ng-model="data"></a>

Config:

ade-id:
	If this id is set, it will be used in messages broadcast to the app on state changes.
ade-classes:
	An array of custom classes to give to the div so that you can use your own images
ade-readonly:
	If you don't want the stars to be editable


 Messages:
 name: ADE-start
 data: id from config

 name: ADE-finish
 data: {id from config, old value, new value}

 ------------------------------------------------------------------*/

angular.module('ADE').directive('adeMulti', ['ADE','$compile','$filter', function(ADE,$compile,$filter) {
	return {
		require: '?ngModel', //optional dependency for ngModel
		restrict: 'A', //Attribute declaration eg: <div ade-multi=""></div>

		scope: {
			adeId: "@",
			adeClasses: "@",
			adeReadonly: "@",
			ngModel: "="
		},

		//The link step (after compile)
		link: function(scope, element, attrs) {
			var iconClasses = ["icon-star-empty","icon-star","icon-heart"];
			var readonly = false;

			if(scope.adeClasses!==undefined) iconClasses = angular.fromJson(scope.adeClasses);
			if(scope.adeReadonly!==undefined && scope.adeReadonly=="1") readonly = true;

			//generates HTML for the star
			var makeHTML = function() {
				var input = scope.ngModel;
				if(angular.isArray(input)) input = input[0];
				if(angular.isString(input)) {
					input = input.toLowerCase();
					if(input=='false' || input=='no') input = 0;
					if(input=='true' || input=='yes') input = 1;
				}
				input = parseInt(input);
				if(isNaN(input)) input = 0;

				scope.ngModel = input;
				
				var editable = (readonly ? "" : " ade-editable");
				var state = '';
				if(iconClasses.length>input) state = iconClasses[input];

				var hoverable = " ade-hover";
				var userAgent = window.navigator.userAgent;
				if(userAgent.match(/iPad/i) || userAgent.match(/iPhone/i)) {
   				hoverable = ""; //iOS web views do a weird thing with hover effects on touch
				}

				element.html('<span class="ade-multi '+editable+hoverable+' '+state+'">');
			}

			var clickHandler = function(e) {
				e.preventDefault();
				e.stopPropagation();

				ADE.begin(scope.adeId);

				var oldValue = scope.ngModel;

				scope.ngModel = parseInt(scope.ngModel);
				if(isNaN(scope.ngModel)) scope.ngModel = 0;
				else scope.ngModel++;

				if(scope.ngModel>=iconClasses.length) scope.ngModel = 0;

				ADE.done(scope.adeId, oldValue, scope.ngModel, 0);

				if($(element).is(':hover')) {
					//It would be nice to remove the hover effect until you leave and rehover
					//would need to register mouseout and touchmove events. yuck
				}
			};

			var focusHandler = function(e) {
				element.on('keypress.ADE', function(e) {
					if (e.keyCode == 13) { //return
						e.preventDefault();
						e.stopPropagation();
						element.click();
					}
				});
			};
			
			//setup events
			if(!readonly) {
				element.on('click.ADE', function(e) {
					scope.$apply(function() {
						clickHandler(e);
					})
				});
				element.on('focus.ADE',  function(e) {
					scope.$apply(function() {
						focusHandler(e);
					})
				});
				element.on('blur.ADE', function(e) {
					element.off('keypress.ADE');
				});
			}

			scope.$on('$destroy', function() { //need to clean up the event watchers when the scope is destroyed
				if(element) {
					element.off('click.ADE');
					element.off('focus.ADE');
					element.off('blur.ADE');
					element.off('keypress.ADE');
				}
			});
			
			//need to watch the model for changes
			scope.$watch(function(scope) {
				return scope.ngModel;
			}, function () {
				makeHTML();
			});

		}
	};
}]);
/* ==================================================================
	AngularJS Datatype Editor - Percent
	A filter to display a number as a percent

	Usage:
	{{ data | percent }}

------------------------------------------------------------------*/

angular.module('ADE').filter('percent', function() {
    return function(input) {
        if(angular.isArray(input)) input = input[0];
        var clean = parseFloat(input);
        var output = '';

        if (!isNaN(clean)) { output = clean + '\u0025' }

        return output;
    };
});


/* ==================================================================
	AngularJS Datatype Editor - Phone number
	A filter to display a phone number
	
	Usage:
	{{ data | phone }}

------------------------------------------------------------------*/

angular.module('ADE').filter('phone', function() {
	return function(input) {
		if(!input) return "";
		if(angular.isArray(input)) input = input[0];
		if(!angular.isString(input)) input = input.toString();
		
		var clean = input.replace(/[\-\.() ]/g, "");
		var html = (!isNaN(parseInt(clean)) && (clean.length >= 7)) ? '<a href="tel:'+clean+'">'+input+'</a>' : input;

		return html;
	 };
});


/* ==================================================================
	AngularJS Datatype Editor - Rating
	A directive to toggle rating icon

	Usage:
	<div ade-rating ade-id='1234' ade-num="10" ade-arrows="1" ng-model="data"></div>

	Config:

	ade-id:
		If this id is set, it will be used in messages broadcast to the app on state changes.
	ade-num:
	 	The number of stars or maximum value for this number
	ade-arrows:
	 	1 to support arrow keys for setting the value
	ade-class:
		A custom class to give to the div so that you can use your own images.
		For icons in the off state, the class will be have "-empty" appended to it.
	ade-width:
		If you use a custom class with different sized images, set the width here
	ade-readonly:
		If you don't want the stars to be editable
	
	 Messages:
	 name: ADE-start
	 data: id from config

	 name: ADE-finish
	 data: {id from config, old value, new value, exit value}

 ------------------------------------------------------------------*/

angular.module('ADE').directive('adeRating', ['ADE', '$compile', '$filter', function(ADE, $compile,$filter) {
	return {
		require: '?ngModel', //optional dependency for ngModel
		restrict: 'A', //Attribute declaration eg: <div ade-rating=""></div>

		scope: {
			adeId: "@",
			adeNum: "@",
			adeArrows: "@",
			adeClass: "@",
			adeWidth: "@",
			adeReadonly: "@",
			ngModel: "="
		},

		//The link step (after compile)
		link: function(scope, element, attrs) {
			var numStars = 5;
			var starWidth = 23;
			var starClass = "icon-star";
			var readonly = false;

			if(scope.adeNum!==undefined) numStars = parseInt(scope.adeNum);
			if(scope.adeWidth!==undefined) starWidth = parseInt(scope.adeWidth);
			if(scope.adeClass!==undefined) starClass = scope.adeClass;
			if(scope.adeReadonly!==undefined && scope.adeReadonly=="1") readonly = true;
			
			var containerW = starWidth * numStars + 10; //10 is for the width of "0 stars" clicable region

			//generates the html for the stars
			var makeHTML = function() {
				var starStatusClass = "-empty";
				var editable = (readonly ? "" : " ade-editable");

				var hoverable = " ade-hover";
				var userAgent = window.navigator.userAgent;
				if(userAgent.match(/iPad/i) || userAgent.match(/iPhone/i)) {
   				hoverable = ""; //iOS web views do a weird thing with hover effects on touch
				}

				var html = '<div class="ade-rating'+editable+hoverable+'" style="width:'+containerW+'px;">';
				html += '<div class="ade-rate-container">';

				var curVal = parseInt(scope.ngModel);
				
				for (var i = 0; i <= numStars; i++) {
					starStatusClass = (i <= curVal) ? "" : "-empty";
					if (i === 0) {
						html += '<a class="ade-rate-one ade-zero" data-position="'+(i)+'">&nbsp;</a>';
					} else {
						html += '<a class="ade-rate-one '+starClass+starStatusClass+' ade-rate'+starStatusClass+'" data-position="'+(i)+'"></a>';
					}
				}

				html += '</div></div>';
				element.html(html);
			};

			//handles the click or keyboard events
			var change = function(val) {
				ADE.begin(scope.adeId);

				//cap val at max
				if (val > numStars) val = numStars;
				if (val < 0) val = 0;

				var oldValue = scope.ngModel;
				scope.ngModel = val;

				makeHTML();

				ADE.done(scope.adeId, oldValue, scope.ngModel, 0);
			};

			//handles clicks on the read version of the data
			var clickHandler = function(e) {
				var val = angular.element(e.target).data('position');
				if (val !== undefined) change(val);
			};

			//on focus, starts watching keyboard
			var focusHandler = function(e) {
				element.on('keydown.ADE', function(e) {
					//console.log(e.keyCode);
					if (e.keyCode >= 96 && e.keyCode <= 105) { //num pad
						e.preventDefault();
						e.stopPropagation();
						change(e.keyCode - 96);
					} else if (e.keyCode >= 48 && e.keyCode <= 57) { //numbers
						e.preventDefault();
						e.stopPropagation();
						change(e.keyCode - 48);
					} else if (e.keyCode == 37 && scope.adeArrows) { //left
						e.preventDefault();
						e.stopPropagation();
						change(scope.ngModel - 1);
					} else if (e.keyCode == 39 && scope.adeArrows) { //right
						e.preventDefault();
						e.stopPropagation();
						if(!angular.isNumber(scope.ngModel)) scope.ngModel = 0;
						change(scope.ngModel + 1);
					}
				});

				element.on('blur.ADE', function(e) {
					element.off('keydown.ADE'); //on blur, stop watching keyboard
				});
			};

			//setup events
			if(!readonly) {
				element.on('click.ADE', function(e) {
					scope.$apply(function() {
						clickHandler(e);
					})
				});
				element.on('focus.ADE',function(e) {
					scope.$apply(function() {
						focusHandler(e);
					})
				});
			}

			scope.$on('$destroy', function() { //need to clean up the event watchers when the scope is destroyed
				if(element) {
					element.off();
				}
			});
			
			//need to watch the model for changes
			scope.$watch(function(scope) {
				return scope.ngModel;
			}, function () {
				makeHTML();
			});
		}
	};
}]);

/*!
 * ngTagsInput v2.1.1
 * http://mbenford.github.io/ngTagsInput
 *
 * Copyright (c) 2013-2014 Michael Benford
 * License: MIT
 *
 * Generated at 2014-09-04 01:27:58 -0300
 */
(function() {
'use strict';

var KEYS = {
    backspace: 8,
    tab: 9,
    enter: 13,
    escape: 27,
    space: 32,
    up: 38,
    down: 40,
    comma: 188
};

var MAX_SAFE_INTEGER = 9007199254740991;
var SUPPORTED_INPUT_TYPES = ['text', 'email', 'url'];

function SimplePubSub() {
    var events = {};
    return {
        on: function(names, handler) {
            names.split(' ').forEach(function(name) {
                if (!events[name]) {
                    events[name] = [];
                }
                events[name].push(handler);
            });
            return this;
        },
        trigger: function(name, args) {
            angular.forEach(events[name], function(handler) {
                handler.call(null, args);
            });
            return this;
        }
    };
}

function makeObjectArray(array, key) {
    array = array || [];
    if (array.length > 0 && !angular.isObject(array[0])) {
        array.forEach(function(item, index) {
            array[index] = {};
            array[index][key] = item;
        });
    }
    return array;
}

function findInObjectArray(array, obj, key) {
    if(array===undefined) {
        return null;
    }
    var item = null;
    for (var i = 0; i < array.length; i++) {
        // I'm aware of the internationalization issues regarding toLowerCase()
        // but I couldn't come up with a better solution right now
        if (safeToString(array[i][key]).toLowerCase() === safeToString(obj[key]).toLowerCase()) {
            item = array[i];
            break;
        }
    }
    return item;
}

function replaceAll(str, substr, newSubstr) {
    if (!substr) {
        return str;
    }

    var expression = substr.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
    return str.replace(new RegExp(expression, 'gi'), newSubstr);
}

function safeToString(value) {
    return angular.isUndefined(value) || value == null ? '' : value.toString().trim();
}

function encodeHTML(value) {
    return value.replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
}

var tagsInput = angular.module('ngTagsInput', []);

/**
 * @ngdoc directive
 * @name tagsInput
 * @module ngTagsInput
 *
 * @description
 * Renders an input box with tag editing support.
 *
 * @param {string} ngModel Assignable angular expression to data-bind to.
 * @param {string=} [displayProperty=text] Property to be rendered as the tag label.
 * @param {string=} [type=text] Type of the input element. Only 'text', 'email' and 'url' are supported values.
 * @param {number=} tabindex Tab order of the control.
 * @param {string=} [placeholder=Add a tag] Placeholder text for the control.
 * @param {number=} [minLength=3] Minimum length for a new tag.
 * @param {number=} [maxLength=MAX_SAFE_INTEGER] Maximum length allowed for a new tag.
 * @param {number=} [minTags=0] Sets minTags validation error key if the number of tags added is less than minTags.
 * @param {number=} [maxTags=MAX_SAFE_INTEGER] Sets maxTags validation error key if the number of tags added is greater than maxTags.
 * @param {boolean=} [allowLeftoverText=false] Sets leftoverText validation error key if there is any leftover text in
 *                                             the input element when the directive loses focus.
 * @param {string=} [removeTagSymbol=×] Symbol character for the remove tag button.
 * @param {boolean=} [addOnEnter=true] Flag indicating that a new tag will be added on pressing the ENTER key.
 * @param {boolean=} [addOnSpace=false] Flag indicating that a new tag will be added on pressing the SPACE key.
 * @param {boolean=} [addOnComma=true] Flag indicating that a new tag will be added on pressing the COMMA key.
 * @param {boolean=} [addOnBlur=true] Flag indicating that a new tag will be added when the input field loses focus.
 * @param {boolean=} [replaceSpacesWithDashes=true] Flag indicating that spaces will be replaced with dashes.
 * @param {string=} [allowedTagsPattern=.+] Regular expression that determines whether a new tag is valid.
 * @param {boolean=} [enableEditingLastTag=false] Flag indicating that the last tag will be moved back into
 *                                                the new tag input box instead of being removed when the backspace key
 *                                                is pressed and the input box is empty.
 * @param {boolean=} [addFromAutocompleteOnly=false] Flag indicating that only tags coming from the autocomplete list will be allowed.
 *                                                   When this flag is true, addOnEnter, addOnComma, addOnSpace, addOnBlur and
 *                                                   allowLeftoverText values are ignored.
 * @param {expression} onTagAdded Expression to evaluate upon adding a new tag. The new tag is available as $tag.
 * @param {expression} onTagRemoved Expression to evaluate upon removing an existing tag. The removed tag is available as $tag.
 */
tagsInput.directive('tagsInput', ["$timeout","$document","tagsInputConfig", function($timeout, $document, tagsInputConfig) {
    function TagList(options, events) {
        var self = {}, getTagText, setTagText, tagIsValid;

        getTagText = function(tag) {
            return safeToString(tag[options.displayProperty]);
        };

        setTagText = function(tag, text) {
            tag[options.displayProperty] = text;
        };

        tagIsValid = function(tag) {
            var tagText = getTagText(tag);

            return tagText &&
                   tagText.length >= options.minLength &&
                   tagText.length <= options.maxLength &&
                   options.allowedTagsPattern.test(tagText) &&
                   !findInObjectArray(self.items, tag, options.displayProperty);
        };

        self.items = [];

        self.addText = function(text) {
            var tag = {};
            setTagText(tag, text);
            return self.add(tag);
        };

        self.add = function(tag) {
            var tagText = getTagText(tag);

            if (options.replaceSpacesWithDashes) {
                tagText = tagText.replace(/\s/g, '-');
            }

            setTagText(tag, tagText);

            if (tagIsValid(tag)) {
                self.items.push(tag);
                events.trigger('tag-added', { $tag: tag });
            }
            else if (tagText) {
                events.trigger('invalid-tag', { $tag: tag });
            }

            return tag;
        };

        self.remove = function(index) {
            var tag = self.items.splice(index, 1)[0];
            events.trigger('tag-removed', { $tag: tag });
            return tag;
        };

        self.removeLast = function() {
            var tag, lastTagIndex = self.items.length - 1;

            if (options.enableEditingLastTag || self.selected) {
                self.selected = null;
                tag = self.remove(lastTagIndex);
            }
            else if (!self.selected) {
                self.selected = self.items[lastTagIndex];
            }

            return tag;
        };

        return self;
    }

    function validateType(type) {
        return SUPPORTED_INPUT_TYPES.indexOf(type) !== -1;
    }

    return {
        restrict: 'E',
        require: 'ngModel',
        scope: {
            tags: '=ngModel',
            onTagAdded: '&',
            onTagRemoved: '&',
            onEscKey: '&',
            onRetKey: '&',
            onBlurred: '&'
        },
        replace: false,
        transclude: true,
        templateUrl: 'ngTagsInput/tags-input.html',
        controller: ["$scope","$attrs","$element", function($scope, $attrs, $element) {
            $scope.events = new SimplePubSub();

            tagsInputConfig.load('tagsInput', $scope, $attrs, {
                type: [String, 'text', validateType],
                placeholder: [String, 'Add a tag'],
                tabindex: [Number, null],
                removeTagSymbol: [String, String.fromCharCode(215)],
                replaceSpacesWithDashes: [Boolean, true],
                minLength: [Number, 3],
                maxLength: [Number, MAX_SAFE_INTEGER],
                addOnEnter: [Boolean, true],
                addOnSpace: [Boolean, false],
                addOnComma: [Boolean, true],
                addOnBlur: [Boolean, true],
                allowedTagsPattern: [RegExp, /.+/],
                enableEditingLastTag: [Boolean, false],
                minTags: [Number, 0],
                maxTags: [Number, MAX_SAFE_INTEGER],
                maxTagsForce: [Number, MAX_SAFE_INTEGER],
                displayProperty: [String, 'text'],
                allowLeftoverText: [Boolean, false],
                addFromAutocompleteOnly: [Boolean, false],
                focusOnLoad: [Boolean, false]
            });

            $scope.tagList = new TagList($scope.options, $scope.events);

            this.registerAutocomplete = function() {
                var input = $element.find('input');
                input.on('keydown', function(e) {
                    $scope.events.trigger('input-keydown', e);
                });

                return {
                    addTag: function(tag) {
                        return $scope.tagList.add(tag);
                    },
                    focusInput: function() {
                        input[0].focus();
                    },
                    getTags: function() {
                        return $scope.tags;
                    },
                    getCurrentTagText: function() {
                        return $scope.newTag.text;
                    },
                    getOptions: function() {
                        return $scope.options;
                    },
                    on: function(name, handler) {
                        $scope.events.on(name, handler);
                        return this;
                    }
                };
            };
        }],
        link: function(scope, element, attrs, ngModelCtrl) {
            var hotkeys = [KEYS.enter, KEYS.comma, KEYS.space, KEYS.backspace],
                tagList = scope.tagList,
                events = scope.events,
                options = scope.options,
                input = element.find('input'),
                validationOptions = ['minTags', 'maxTags', 'allowLeftoverText'],
                setElementValidity,
                blurOnTouch,
                waitForBlur;

            setElementValidity = function() {
                ngModelCtrl.$setValidity('maxTags', scope.tags.length <= options.maxTags);
                ngModelCtrl.$setValidity('minTags', scope.tags.length >= options.minTags);
                ngModelCtrl.$setValidity('leftoverText', options.allowLeftoverText ? true : !scope.newTag.text);
            };

            blurOnTouch = function(e) {
                if(!element[0].contains(e.target)) {
                    if(input[0]) {
                        input[0].blur();
                    }
                }
            };

            events
                .on('tag-added', scope.onTagAdded)
                .on('tag-removed', scope.onTagRemoved)
                .on('esc-pressed', scope.onEscKey)
                .on('tag-added', function() {
                    //supports FIFO tag list with enforcing number of tags
                    if(options.maxTagsForce && scope.tags.length>options.maxTagsForce) {
                        scope.tags = scope.tags.slice(1,options.maxTagsForce+1);
                    }
                    scope.newTag.text = '';
                })
                .on('tag-added tag-removed', function() {
                    ngModelCtrl.$setViewValue(scope.tags);
                })
                .on('ret-pressed', function(e) {
                    scope.onRetKey({e:e});
                })
                .on('invalid-tag', function() {
                    scope.newTag.invalid = true;
                })
                .on('input-change', function() {
                    tagList.selected = null;
                    scope.newTag.invalid = null;
                })
                .on('input-focus', function() {
                    ngModelCtrl.$setValidity('leftoverText', true);

                    //blur on outside tap when on touch device
                    $document.on('touchend', blurOnTouch);
                })
                .on('input-blur', function() {
                    if (!options.addFromAutocompleteOnly) {
                        if (options.addOnBlur) {
                            tagList.addText(scope.newTag.text);
                        }

                        setElementValidity();
                    }
                    $document.off('touchend', blurOnTouch);
                    scope.onBlurred({how:scope.tabPressed ? scope.tabPressed : 0});
                })
                .on('option-change', function(e) {
                    if (validationOptions.indexOf(e.name) !== -1) {
                        setElementValidity();
                    }
                });

            scope.newTag = { text: '', invalid: null };

            scope.getDisplayText = function(tag) {
                return safeToString(tag[options.displayProperty]);
            };

            scope.track = function(tag) {
                return tag[options.displayProperty];
            };

            scope.newTagChange = function() {
                events.trigger('input-change', scope.newTag.text);
            };

            scope.$watch('tags', function(value) {
                scope.tags = makeObjectArray(value, options.displayProperty);
                tagList.items = scope.tags;
            });

            scope.$watch('tags.length', function() {
                setElementValidity();
            });

            input
                .on('keydown', function(e) {
                    // This hack is needed because jqLite doesn't implement stopImmediatePropagation properly.
                    // I've sent a PR to Angular addressing this issue and hopefully it'll be fixed soon.
                    // https://github.com/angular/angular.js/pull/4833
                    if (e.isImmediatePropagationStopped && e.isImmediatePropagationStopped()) {
                        return;
                    }

                    var key = e.keyCode,
                        isModifier = e.shiftKey || e.altKey || e.ctrlKey || e.metaKey,
                        addKeys = {},
                        shouldAdd, shouldRemove;

                    if (key === KEYS.escape) { //if esc key is pressed without autocomplete open, tell caller
                        scope.events.trigger('esc-pressed');
                    }
                    else if (key === KEYS.enter && scope.newTag.text==='') { // if ret key is pressed with nothing typed, tell caller
                        scope.events.trigger('ret-pressed',e);
                    }
                    else if (key === KEYS.tab) { //if tab key is pressed (or shift tab) save the info for feeding to onBlur callback
                        scope.tabPressed = e.shiftKey ? -1 : 1;
                    }

                    if (isModifier || hotkeys.indexOf(key) === -1) {
                        return;
                    }

                    addKeys[KEYS.enter] = options.addOnEnter;
                    addKeys[KEYS.comma] = options.addOnComma;
                    addKeys[KEYS.space] = options.addOnSpace;

                    shouldAdd = !options.addFromAutocompleteOnly && addKeys[key];
                    shouldRemove = !shouldAdd && key === KEYS.backspace && scope.newTag.text.length === 0;

                    if (shouldAdd) {
                        tagList.addText(scope.newTag.text);

                        scope.$apply();
                        e.preventDefault();
                    }
                    else if (shouldRemove) {
                        var tag = tagList.removeLast();
                        if (tag && options.enableEditingLastTag) {
                            scope.newTag.text = tag[options.displayProperty];
                        }

                        scope.$apply();
                        e.preventDefault();
                    }
                })
                .on('focus', function() {
                    if (scope.hasFocus) {
                        return;
                    }

                    scope.hasFocus = true;
                    events.trigger('input-focus');

                    $timeout(function() { //inside a timeout to prevent $digest loop conflict
                        scope.$apply();
                    });
                })
                .on('blur', function() {
                    waitForBlur = $timeout(function() {
                        var activeElement = $document.prop('activeElement'),
                            lostFocusToBrowserWindow = activeElement === input[0],
                            lostFocusToChildElement = element[0].contains(activeElement);

                        if (lostFocusToBrowserWindow === lostFocusToChildElement) {
                            scope.hasFocus = false;
                            events.trigger('input-blur');
                        }
                    });
                });

            element.find('div').on('click', function() {
                $timeout.cancel(waitForBlur);
                input[0].focus();
            });

            if(options.focusOnLoad) { //ADE: added to focus on load
                input[0].focus();
            }
        }
    };
}]);

/**
 * @ngdoc directive
 * @name autoComplete
 * @module ngTagsInput
 *
 * @description
 * Provides autocomplete support for the tagsInput directive.
 *
 * @param {expression} source Expression to evaluate upon changing the input content. The input value is available as
 *                            $query. The result of the expression must be a promise that eventually resolves to an
 *                            array of strings.
 * @param {number=} [debounceDelay=100] Amount of time, in milliseconds, to wait before evaluating the expression in
 *                                      the source option after the last keystroke.
 * @param {number=} [minLength=3] Minimum number of characters that must be entered before evaluating the expression
 *                                 in the source option.
 * @param {boolean=} [highlightMatchedText=true] Flag indicating that the matched text will be highlighted in the
 *                                               suggestions list.
 * @param {number=} [maxResultsToShow=10] Maximum number of results to be displayed at a time.
 * @param {boolean=} [loadOnDownArrow=false] Flag indicating that the source option will be evaluated when the down arrow
 *                                           key is pressed and the suggestion list is closed. The current input value
 *                                           is available as $query.
 * @param {boolean=} {loadOnEmpty=false} Flag indicating that the source option will be evaluated when the input content
 *                                       becomes empty. The $query variable will be passed to the expression as an empty string.
 * @param {boolean=} {loadOnFocus=false} Flag indicating that the source option will be evaluated when the input element
 *                                       gains focus. The current input value is available as $query.
 */
tagsInput.directive('autoComplete', ["$document","$timeout","$sce","tagsInputConfig", function($document, $timeout, $sce, tagsInputConfig) {
    function SuggestionList(loadFn, options) {
        var self = {}, debouncedLoadId, getDifference, lastPromise;

        getDifference = function(array1, array2) {
            return array1.filter(function(item) {
                return !findInObjectArray(array2, item, options.tagsInput.displayProperty);
            });
        };

        self.reset = function() {
            lastPromise = null;

            self.items = [];
            self.visible = false;
            self.index = -1;
            self.selected = null;
            self.query = null;

            $timeout.cancel(debouncedLoadId);
        };
        self.show = function() {
            self.selected = null;
            self.visible = true;
        };
        self.load = function(query, tags) {
            $timeout.cancel(debouncedLoadId);
            debouncedLoadId = $timeout(function() {
                self.query = query;

                var promise = loadFn({ $query: query });
                lastPromise = promise;

                promise.then(function(items) {
                    if (promise !== lastPromise) {
                        return;
                    }

                    items = makeObjectArray(items.data || items, options.tagsInput.displayProperty);
                    items = getDifference(items, tags);
                    self.items = items.slice(0, options.maxResultsToShow);

                    if (self.items.length > 0) {
                        self.show();
                    }
                    else {
                        self.reset();
                    }
                });
            }, options.debounceDelay, false);
        };
        self.selectNext = function() {
            self.select(++self.index);
        };
        self.selectPrior = function() {
            self.select(--self.index);
        };
        self.select = function(index) {
            if (index < 0) {
                index = self.items.length - 1;
            }
            else if (index >= self.items.length) {
                index = 0;
            }
            self.index = index;
            self.selected = self.items[index];
        };

        self.reset();

        return self;
    }

    return {
        restrict: 'E',
        require: '^tagsInput',
        scope: { source: '&' },
        templateUrl: 'ngTagsInput/auto-complete.html',
        link: function(scope, element, attrs, tagsInputCtrl) {
            var hotkeys = [KEYS.enter, KEYS.tab, KEYS.escape, KEYS.up, KEYS.down],
                suggestionList, tagsInput, options, getItem, getDisplayText, shouldLoadSuggestions;

            tagsInputConfig.load('autoComplete', scope, attrs, {
                debounceDelay: [Number, 100],
                minLength: [Number, 3],
                highlightMatchedText: [Boolean, true],
                maxResultsToShow: [Number, 10],
                loadOnDownArrow: [Boolean, false],
                loadOnEmpty: [Boolean, false],
                loadOnFocus: [Boolean, false]
            });

            options = scope.options;

            tagsInput = tagsInputCtrl.registerAutocomplete();
            options.tagsInput = tagsInput.getOptions();

            suggestionList = new SuggestionList(scope.source, options);

            getItem = function(item) {
                return item[options.tagsInput.displayProperty];
            };

            getDisplayText = function(item) {
                return safeToString(getItem(item));
            };

            shouldLoadSuggestions = function(value) {
                return value && value.length >= options.minLength || !value && options.loadOnEmpty;
            };

            scope.suggestionList = suggestionList;

            scope.addSuggestionByIndex = function(index) {
                suggestionList.select(index);
                scope.addSuggestion();
            };

            scope.addSuggestion = function() {
                var added = false;

                if (suggestionList.selected) {
                    tagsInput.addTag(suggestionList.selected);
                    suggestionList.reset();
                    tagsInput.focusInput();

                    added = true;
                }
                return added;
            };

            scope.highlight = function(item) {
                var text = getDisplayText(item);
                text = encodeHTML(text);
                if (options.highlightMatchedText) {
                    text = replaceAll(text, encodeHTML(suggestionList.query), '<em>$&</em>');
                }
                return $sce.trustAsHtml(text);
            };

            scope.track = function(item) {
                return getItem(item);
            };

            tagsInput
                .on('invalid-tag input-blur', function() {
                    suggestionList.reset();
                })
                .on('tag-added tag-removed', function() {
                    suggestionList.reset();
                    
                    //must give input chance to reset before we attempt to present the autocomplete again
                    $timeout(function() {
                        var value = tagsInput.getCurrentTagText();
                        if (options.loadOnFocus && shouldLoadSuggestions(value)) {
                            suggestionList.load(value, tagsInput.getTags());
                        }
                    });
                })
                .on('input-change', function(value) {
                    if (shouldLoadSuggestions(value)) {
                        suggestionList.load(value, tagsInput.getTags());
                    }
                    else {
                        suggestionList.reset();
                    }
                })
                .on('input-focus', function() {
                    var value = tagsInput.getCurrentTagText();
                    if (options.loadOnFocus && shouldLoadSuggestions(value)) {
                        suggestionList.load(value, tagsInput.getTags());
                    }
                })
                .on('input-keydown', function(e) {
                    // This hack is needed because jqLite doesn't implement stopImmediatePropagation properly.
                    // I've sent a PR to Angular addressing this issue and hopefully it'll be fixed soon.
                    // https://github.com/angular/angular.js/pull/4833
                    var immediatePropagationStopped = false;
                    e.stopImmediatePropagation = function() {
                        immediatePropagationStopped = true;
                        e.stopPropagation();
                    };
                    e.isImmediatePropagationStopped = function() {
                        return immediatePropagationStopped;
                    };

                    var key = e.keyCode,
                        handled = false;

                    if (hotkeys.indexOf(key) === -1) {
                        return;
                    }

                    if (suggestionList.visible) {

                        if (key === KEYS.down) {
                            suggestionList.selectNext();
                            handled = true;
                        }
                        else if (key === KEYS.up) {
                            suggestionList.selectPrior();
                            handled = true;
                        }
                        else if (key === KEYS.escape) {
                            suggestionList.reset();
                            handled = true;
                        }
                        else if (key === KEYS.enter || key === KEYS.tab) {
                            handled = scope.addSuggestion();
                        }
                    }
                    else {
                        if (key === KEYS.down && scope.options.loadOnDownArrow) {
                            suggestionList.load(tagsInput.getCurrentTagText(), tagsInput.getTags());
                            handled = true;
                        }
                    }

                    if (handled) {
                        e.preventDefault();
                        e.stopImmediatePropagation();
                        scope.$apply();
                    }
                });
        }
    };
}]);


/**
 * @ngdoc directive
 * @name tiTranscludeAppend
 * @module ngTagsInput
 *
 * @description
 * Re-creates the old behavior of ng-transclude. Used internally by tagsInput directive.
 */
tagsInput.directive('tiTranscludeAppend', function() {
    return function(scope, element, attrs, ctrl, transcludeFn) {
        transcludeFn(function(clone) {
            element.append(clone);
        });
    };
});

/**
 * @ngdoc directive
 * @name tiAutosize
 * @module ngTagsInput
 *
 * @description
 * Automatically sets the input's width so its content is always visible. Used internally by tagsInput directive.
 */
tagsInput.directive('tiAutosize', ["tagsInputConfig", function(tagsInputConfig) {
    return {
        restrict: 'A',
        require: 'ngModel',
        link: function(scope, element, attrs, ctrl) {
            var threshold = tagsInputConfig.getTextAutosizeThreshold(),
                span, resize;

            span = angular.element('<span class="input"></span>');
            span.css('display', 'none')
                .css('visibility', 'hidden')
                .css('width', 'auto')
                .css('white-space', 'pre');

            element.parent().append(span);

            resize = function(originalValue) {
                var value = originalValue, width;

                if (angular.isString(value) && value.length === 0) {
                    value = attrs.placeholder;
                }

                if (value) {
                    span.text(value);
                    span.css('display', '');
                    width = span.prop('offsetWidth');
                    span.css('display', 'none');
                }

                element.css('width', width ? width + threshold + 'px' : '');

                return originalValue;
            };

            ctrl.$parsers.unshift(resize);
            ctrl.$formatters.unshift(resize);

            attrs.$observe('placeholder', function(value) {
                if (!ctrl.$modelValue) {
                    resize(value);
                }
            });
        }
    };
}]);

/**
 * @ngdoc directive
 * @name tiBindAttrs
 * @module ngTagsInput
 *
 * @description
 * Binds attributes to expressions. Used internally by tagsInput directive.
 */
tagsInput.directive('tiBindAttrs', function() {
    return function(scope, element, attrs) {
        scope.$watch(attrs.tiBindAttrs, function(value) {
            angular.forEach(value, function(value, key) {
                attrs.$set(key, value);
            });
        }, true);
    };
});

/**
 * @ngdoc service
 * @name tagsInputConfig
 * @module ngTagsInput
 *
 * @description
 * Sets global configuration settings for both tagsInput and autoComplete directives. It's also used internally to parse and
 * initialize options from HTML attributes.
 */
tagsInput.provider('tagsInputConfig', function() {
    var globalDefaults = {},
        interpolationStatus = {},
        autosizeThreshold = 3;

    /**
     * @ngdoc method
     * @name setDefaults
     * @description Sets the default configuration option for a directive.
     * @methodOf tagsInputConfig
     *
     * @param {string} directive Name of the directive to be configured. Must be either 'tagsInput' or 'autoComplete'.
     * @param {object} defaults Object containing options and their values.
     *
     * @returns {object} The service itself for chaining purposes.
     */
    this.setDefaults = function(directive, defaults) {
        globalDefaults[directive] = defaults;
        return this;
    };

    /***
     * @ngdoc method
     * @name setActiveInterpolation
     * @description Sets active interpolation for a set of options.
     * @methodOf tagsInputConfig
     *
     * @param {string} directive Name of the directive to be configured. Must be either 'tagsInput' or 'autoComplete'.
     * @param {object} options Object containing which options should have interpolation turned on at all times.
     *
     * @returns {object} The service itself for chaining purposes.
     */
    this.setActiveInterpolation = function(directive, options) {
        interpolationStatus[directive] = options;
        return this;
    };

    /***
     * @ngdoc method
     * @name setTextAutosizeThreshold
     * @methodOf tagsInputConfig
     *
     * @param {number} threshold Threshold to be used by the tagsInput directive to re-size the input element based on its contents.
     *
     * @returns {object} The service itself for chaining purposes.
     */
    this.setTextAutosizeThreshold = function(threshold) {
        autosizeThreshold = threshold;
        return this;
    };

    this.$get = ["$interpolate", function($interpolate) {
        var converters = {};
        converters[String] = function(value) { return value; };
        converters[Number] = function(value) { return parseInt(value, 10); };
        converters[Boolean] = function(value) { return value.toLowerCase() === 'true'; };
        converters[RegExp] = function(value) { return new RegExp(value); };

        return {
            load: function(directive, scope, attrs, options) {
                var defaultValidator = function() { return true; };

                scope.options = {};

                angular.forEach(options, function(value, key) {
                    var type, localDefault, validator, converter, getDefault, updateValue;

                    type = value[0];
                    localDefault = value[1];
                    validator = value[2] || defaultValidator;
                    converter = converters[type];

                    getDefault = function() {
                        var globalValue = globalDefaults[directive] && globalDefaults[directive][key];
                        return angular.isDefined(globalValue) ? globalValue : localDefault;
                    };

                    updateValue = function(value) {
                        scope.options[key] = value && validator(value) ? converter(value) : getDefault();
                    };

                    if (interpolationStatus[directive] && interpolationStatus[directive][key]) {
                        attrs.$observe(key, function(value) {
                            updateValue(value);
                            scope.events.trigger('option-change', { name: key, newValue: value });
                        });
                    }
                    else {
                        updateValue(attrs[key] && $interpolate(attrs[key])(scope.$parent));
                        if(key==='tabindex') {
                            attrs[key] = -1; // fixes tab key entering input correctly
                        }
                    }
                });
            },
            getTextAutosizeThreshold: function() {
                return autosizeThreshold;
            }
        };
    }];
});


/* HTML templates */
tagsInput.run(["$templateCache", function($templateCache) {
    $templateCache.put('ngTagsInput/tags-input.html',
    "<div class=\"host\" tabindex=\"-1\" ti-transclude-append=\"\"><div class=\"tags\" ng-class=\"{focused: hasFocus}\"><ul class=\"tag-list\"><li class=\"tag-item\" ng-repeat=\"tag in tagList.items track by track(tag)\" ng-class=\"{ selected: tag == tagList.selected }\"><span ng-bind=\"getDisplayText(tag)\"></span> <a class=\"remove-button\" ng-click=\"tagList.remove($index)\" ng-bind=\"options.removeTagSymbol\"></a></li></ul><input class=\"input\" ng-model=\"newTag.text\" ng-change=\"newTagChange()\" ng-trim=\"false\" ng-class=\"{'invalid-tag': newTag.invalid}\" ti-bind-attrs=\"{type: options.type, placeholder: options.placeholder, tabindex: options.tabindex}\" ti-autosize=\"\"></div></div>"
  );

  $templateCache.put('ngTagsInput/auto-complete.html',
    "<div class=\"autocomplete\" ng-show=\"suggestionList.visible\"><ul class=\"suggestion-list\"><li class=\"suggestion-item\" ng-repeat=\"item in suggestionList.items track by track(item)\" ng-class=\"{selected: item == suggestionList.selected}\" ng-click=\"addSuggestionByIndex($index)\" ng-mouseenter=\"suggestionList.select($index)\" ng-bind-html=\"highlight(item)\"></li></ul></div>"
  );
}]);

}());
/* ==================================================================
AngularJS Datatype Editor - Tag
A directive to pick multiple values from a list or add a new value

This directive uses a modified version of ngTagsInput
http://mbenford.github.io/ngTagsInput

You will need to include ngTagsInput as a dependency to your app

Usage:
<div ade-tag="list1" ade-id="123" ade-query="query(val,listId)" ng-model="data"></div>

Config:

ade-tag:
	The id number for the type of list. If you have multiple lists per page, this will
	distinguish between them
ade-id:
	If this id is set, it will be used in messages broadcast to the app on state changes.
ade-readonly:
	If you don't want the list to be editable	
ade-query:
	A function in your controller that will provide matches for search query.
	The argument names need to match

 Messages:
 name: ADE-start
 data: id from config

 name: ADE-finish
 data: {id from config, old value, new value, exit value}

 ------------------------------------------------------------------*/

angular.module('ADE').directive('adeTag', 
 ['ADE', '$compile', '$filter', '$sanitize', 
 function(ADE, $compile, $filter, $sanitize) {
	return {
		require: '?ngModel', //optional dependency for ngModel
		restrict: 'A', //Attribute declaration eg: <div ade-toggle=""></div>

		scope: {
			adeTag: "@",
			adeId: "@",
			adeClass: "@",
			adeQuery: "&",
			adeReadonly: "@",
			ngModel: "="
		},

		//The link step (after compile)
		link: function(scope, element, attrs) {
			var editing = false; //are we in edit mode or not
			var input = null; //a reference to the input DOM object
			var readonly = false;
			var exit = 0; //0=click, 1=tab, -1= shift tab, 2=return, -2=shift return, 3=esc. controls if you exited the field so you can focus the next field if appropriate
			var stopObserving = null;
			var adeId = scope.adeId;

			if(scope.adeReadonly!==undefined && scope.adeReadonly=="1") readonly = true;

			scope.query = function(val) { //called by ng-tags-input on each keystroke to get the autocomplete
				return scope.adeQuery({val:val, listId: scope.adeTag});
			};
			scope.esc = function() { //called by ng-tags-input when esc key is pressed 
				destroy();
				ADE.done(adeId, scope.ngModel, scope.ngModel, 3);
			};
			scope.ret = function(e) {
				var exit = e.shiftKey ? -2 : 2;
				saveEdit(exit);
			};
			scope.tab = function(e) {
				var exit = e.shiftKey ? -1 : 1;
				saveEdit(exit);
			};
			scope.blurred = function(how) {
				saveEdit(how);
			};


			//generates HTML for the star
			var makeHTML = function() {
				var html = "";

				if (scope.ngModel!==undefined) {
					if (angular.isString(scope.ngModel)) {
						html = scope.ngModel;
					} else if (angular.isArray(scope.ngModel)) {
						var html = '';
						$.each(scope.ngModel, function(i, v) {
							if (html) html += ', ';
							html += v;
						});
					}
				}
				html = $sanitize(html).replace(/<[^>]+>/gm, '');
				element.html(html);
			}

			//called once the edit is done, so we can save the new data and remove edit mode
			var saveEdit = function(exited) {
				var oldValue = scope.ngModel;
				exit = exited;

				if (exited != 3) { //don't save value on esc
					var value = scope.tags;
					if (angular.isArray(value)) {
						if (value.length > 0) {
							//to have value stored as array
							var vals = [];
							angular.forEach(value, function(val, key) {
								if(val.text) vals.push(val.text);
							});
							value = vals;
						} else {
							value = null;
						}
					} else if (angular.isObject(value) && value.text) {
						value = value.text;
					} else {
						value = (value) ? value.text : null;
					}

					scope.ngModel = value;
				}

				destroy();

				ADE.done(adeId, oldValue, scope.ngModel, exit);
			};


			var clickHandler = function(e) {
				if (editing) return;
				editing = true;
				exit = 0;

				adeId = scope.adeId;
				ADE.begin(adeId);
				element.hide();

				var listId = '';
				if (scope.adeList) listId = scope.adeList; //data that is passed through to the query function

				var autocomplete = "query($query)";

				scope.tags = angular.copy(scope.ngModel);
				if (angular.isString(scope.tags)) scope.tags = scope.tags.split(',');

				var html = '<tags-input class="ade-tag-input" ng-model="tags" min-length="1" replace-spaces-with-dashes="false" enable-editing-last-tag="true" on-esc-key="esc()" on-ret-key="ret(e)" on-blurred="blurred(how)" focus-on-load="true"><auto-complete source="'+autocomplete+'" min-length="1" load-on-empty="true" load-on-focus="true"></auto-complete></tags-input>';
				$compile(html)(scope).insertAfter(element);

				$('.ade-tag-input').on("keydown",function(e) { //prevent tab key from doing default behavior
					if (e.keyCode == 9) { //tab
						e.preventDefault();
						e.stopPropagation();
						input.blur();
					}
				});

				setTimeout(function() {
					input = $('.ade-tag-input .tag-list + input');
				},100); //tag input needs little time to initialize before it can accept a focus

			};

			var focusHandler = function(e) {
				element.on('keypress.ADE', function(e) {
					if (e.keyCode == 13) { //return
						e.preventDefault();
						e.stopPropagation();
						element.click();
					}
				});
			};
			
			//setup events
			if(!readonly) {
				element.on('click.ADE', function(e) {
					scope.$apply(function() {
						clickHandler(e);
					})
				});
				element.on('focus.ADE',  function(e) {
					scope.$apply(function() {
						focusHandler(e);
					})
				});
				element.on('blur.ADE', function(e) {
					element.off('keypress.ADE');
				});
			}


			//A callback to observe for changes to the id and save edit
			//The model will still be connected, so it is safe, but don't want to cause problems
			var observeID = function(value) {
				 //this gets called even when the value hasn't changed, 
				 //so we need to check for changes ourselves
				 if(editing && adeId!==value) saveEdit(3);
			};

			//If ID changes during edit, something bad happened. No longer editing the right thing. Cancel
			stopObserving = attrs.$observe('adeId', observeID);

			var destroy = function() {
				element.show();

				if(input) input.off();
				$('.ade-tag-input').off();
				$('.ade-tag-input').remove();

				ADE.teardownBlur();

				editing = false;
			};

			scope.$on('$destroy', function() { //need to clean up the event watchers when the scope is destroyed
				destroy();

				if(element) {
					element.off('click.ADE');
					element.off('focus.ADE');
					element.off('blur.ADE');
					element.off('keypress.ADE');
				}

				if(stopObserving && stopObserving!=observeID) { //Angualar <=1.2 returns callback, not deregister fn
					stopObserving();
					stopObserving = null;
				} else {
					delete attrs.$$observers['adeId'];
				}
			});
			
			//need to watch the model for changes
			scope.$watch(function(scope) {
				return scope.ngModel;
			}, function () {
				makeHTML();
			});

		}
	};
}]);
/* ==================================================================
	AngularJS Datatype Editor - Text
	A directive to edit text in place

	Usage:
	<div ade-text ade-class="input-large" ade-id="1235" ade-max="20" ng-model="data"></div>

	Config:

	ade-id:
		If this id is set, it will be used in messages broadcast to the app on state changes.
	ade-class:
		A custom class to give to the input
	ade-readonly:
		If you don't want the stars to be editable	
	ade-max:
		The optional maximum length to enforce

	Messages:
		name: ADE-start
		data: id from config

		name: ADE-finish
		data: {id from config, old value, new value, exit value}

------------------------------------------------------------------*/

angular.module('ADE').directive('adeText', ['ADE','$compile','$sanitize',function(ADE,$compile,$sanitize) {
	return {
		require: '?ngModel', //optional dependency for ngModel
		restrict: 'A', //Attribute declaration eg: <div ade-text=""></div>

		scope: {
			adeId: "@",
			adeClass: "@",
			adeReadonly: "@",
			adeMax: "@",
			ngModel: "="
		},

		//The link step (after compile)
		link: function(scope, element, attrs) {
			var editing=false; //are we in edit mode or not
			var input = null; //a reference to the input DOM object
			var exit = 0; //0=click, 1=tab, -1= shift tab, 2=return, -2=shift return, 3=esc. controls if you exited the field so you can focus the next field if appropriate
			var maxlength = 0;
			var readonly = false;
			var inputClass = "";
			var stopObserving = null;
			var adeId = scope.adeId;

			if(scope.adeClass!==undefined) inputClass = scope.adeClass;
			if(scope.adeReadonly!==undefined && scope.adeReadonly=="1") readonly = true;
			if(scope.adeMax!==undefined) maxlength = parseInt(scope.adeMax);

			var makeHTML = function() {
				var html = "";
				var value = scope.ngModel;
				
				//TODO: truncate to maxlength for display of pre-existing data
				if(value!==undefined) {
					if (angular.isArray(value)) value = value[0];
					if (!value.split) value = value.toString(); //convert to string if not string (to prevent split==undefined)
					value = $sanitize(value).replace(/<[^>]+>/gm, '');

					html = value;
				}
				element.html(html);
			};

			//called once the edit is done, so we can save the new data	and remove edit mode
			var saveEdit = function(exited) {
				var oldValue = scope.ngModel;
				exit = exited;

				if(exited!=3) { //don't save value on esc
					scope.ngModel = input.val();
				}

				element.show();
				input.remove();
				editing=false;

				ADE.done(adeId, oldValue, scope.ngModel, exit);
				ADE.teardownBlur(input);
				ADE.teardownKeys(input);
			};

			var clickHandler = function() {
				if(editing) return;
				editing=true;
				exit = 0;

				adeId = scope.adeId;
				ADE.begin(adeId);

				var maxtag = '';
				if(maxlength!==undefined && maxlength!=0 && !isNaN(maxlength)) maxtag = "maxlength='"+maxlength+"'";

				var value = scope.ngModel;
				if(value==undefined || value==null) value="";
				if(!angular.isString(value)) value = value.toString();
				
				element.hide();
				$compile('<input type="text" class="ade-input '+inputClass+'" value="'+value.replace(/"/g,'&quot;')+'" '+maxtag+' />')(scope).insertAfter(element);
				input = element.next('input');
				input.focus();
				
				//put cursor at end
				input[0].selectionStart = input[0].selectionEnd = input.val().length; 

				ADE.setupBlur(input,saveEdit,scope);
				ADE.setupKeys(input,saveEdit,false,scope);
			};

			//setup events
			if(!readonly) {
				element.on('click.ADE', function(e) {
					scope.$apply(function() {
						clickHandler(e);
					})
				});
			}

			//A callback to observe for changes to the id and save edit
			//The model will still be connected, so it is safe, but don't want to cause problems
			var observeID = function(value) {
				 //this gets called even when the value hasn't changed, 
				 //so we need to check for changes ourselves
				 if(editing && adeId!==value) saveEdit(3);
			};

			//If ID changes during edit, something bad happened. No longer editing the right thing. Cancel
			stopObserving = attrs.$observe('adeId', observeID);

			scope.$on('$destroy', function() { //need to clean up the event watchers when the scope is destroyed
				if(element) element.off('click.ADE');
			
				if(stopObserving && stopObserving!=observeID) { //Angualar <=1.2 returns callback, not deregister fn
					stopObserving();
					stopObserving = null;
				} else {
					delete attrs.$$observers['adeId'];
				}
			});

			//need to watch the model for changes
			scope.$watch(function(scope) {
				return scope.ngModel;
			}, function () {
				makeHTML();
			});
		}
	};
}]);
/* ==================================================================
	AngularJS Datatype Editor - Time
	Two directives to edit a time. One directive is responsible for creating a popup 
	picker on an input. The second direcrtive is responsible for creating that input
	when clicking on a time.

------------------------------------------------------------------*/


/* ==================================================================
 Directive to present a time picker on an input

 Usage:
	<input ade-timepop='12' ng-model="data"></div>

	Config:

	ade-timepop:
		Specify "12" for am/pm time or "24" for 24 hour time.

 ------------------------------------------------------------------*/

angular.module('ADE').directive('adeTimepop', ['$filter',function($filter){
	return {
		require: '?ngModel', //optional dependency for ngModel
		restrict: 'A', //Attribute declaration eg: <div ade-timepop=""></div>

		scope: {
			adeTimepop: "@",
			ngModel: "="
		},

		//The link step (after compile)
		link: function(scope, element, attrs) {
			var keydown = false;

			var format = '12';
			if(scope.adeTimepop!==undefined) format = scope.adeTimepop;

			//creates a callback for when the time is changed, we need to make
			//sure that it is formatted correctly
			var updateModel = function() {
				if(!keydown) { //don't want to reformat time if in middle of keypress
					scope.ngModel  = $filter('time')(scope.ngModel, format);
				}
			};

			var updateWidget = function() {
					var timeStr = element.context.value;
					var pickerData = element.timepicker().data().timepicker;
					if(angular.isString(timeStr)) {
						var arr = timeStr.split(' ');
						var hrsmin = arr[0].split(':');
						var hours = parseInt(hrsmin[0], 10);
						var mins = parseInt(hrsmin[1], 10);
						var ampm = arr[1];
						var validHrs = (hours <= 23) ? hours : 23;
						var validMins = (mins <= 59) ? mins : 59;
						pickerData.hour = validHrs;
						pickerData.minute = validMins;
						pickerData.meridian = ampm;
					}
					element.timepicker('updateWidget');

					//var timeFormat = element.timepicker().data().timepicker.options.showMeridian;
					//var filteredValue = (timeFormat) ? $filter('time')(scope.ngModel) : $filter('time')(scope.ngModel, "24");
					//element.timepicker('setValues', filteredValue);
					//element.timepicker('update');
			};

			//on a valid keypress, recaculates the time
			var updateFromKey = function(e) {
				var validKey = isValidKey(e);
				keydown = false;
				if (validKey && e.keyCode!=13 && e.keyCode!=27 && e.keyCode!=9 && e.keyCode!=8) {

					//need to set timeout because keyup hasn't yet entered the input
					setTimeout(function() {
						updateWidget();
					},100);
				}
				return true;
			};

			//prepares the keyup event to handle valid keypresses
			var isValidKey = function(e) {
				//valid keys: 1-0, p, a, m,backspace, space,return,esc,space
				var keys = [49,50,51,52,53,54,55,56,57,109,112,97,48,58,8,186,13,27,32];
				var validKey = false;

				for (var i=0;i<keys.length;i++) {
					if (!validKey) {
						if (e.keyCode === keys[i]) {
							// keydown=false;
							validKey = true;
							return (element.length < 8) ? validKey : false;
						} else {
							validKey = false;
						}
					}
				}

				return validKey;
			};

			//Handles return, esc, tab key pressed on in-line text box
			element.on('keydown.ADE', function(e) {
				keydown = true;
				if(e.keyCode==13) { //return key
					element.timepicker('updateWidget');
					element.timepicker('hideWidget');
					element.blur();
				} else if (e.keyCode==27) { //esc
					element.timepicker('hideWidget', false);
				} else if(e.keyCode==9) { //tab key detection
					element.timepicker('updateWidget');
					element.timepicker('hideWidget', true);
				} 
			});

			element.on('keyup.ADE', updateFromKey); //needs to be on keyup because some keys (delete) are not send on press

			//initialization of the datapicker
			element.timepicker({showMeridian:format=="24" ? false : true });
	
			var destroy = function() { //need to clean up the event watchers when the scope is destroyed
				if(element) {
					element.off('keydown.ADE');
					element.off('keyup.ADE');
					if(element.timepicker) element.timepicker('removeWidget');
				}
				if(unwatch) unwatch();
			};

			scope.$on('$destroy', destroy);

			//need to watch the model for changes
			var unwatch = scope.$watch(function(scope) {
				return scope.ngModel;
			}, function () {
				if(scope.ngModel===-2) destroy();
				else updateModel();
			});

		}
	};
}]);

/* ==================================================================
 Directive to display a popup to pick a time

 	Usage:
	<div ade-time='12' ade-id='1234' ade-class="myClass" ng-model="data"></div>

	Config:

	ade-time:
		Specify "12" for am/pm time or "24" for 24 hour time.
	ade-id:
		If this id is set, it will be used in messages broadcast to the app on state changes.
	ade-class:
		A custom class to give to the input
	ade-readonly:
		If you don't want the date to be editable

	Messages:
		name: ADE-start
		data: id from config

		name: ADE-finish
		data: {id from config, old value, new value, exit value}

 ------------------------------------------------------------------*/
angular.module('ADE').directive('adeTime', ['ADE', '$compile', '$filter', function(ADE, $compile, $filter) {
	return {
		require: '?ngModel', //optional dependency for ngModel
		restrict: 'A', //Attribute declaration eg: <div ade-time=""></div>

		scope: {
			adeTime: "@",
			adeId: "@",
			adeClass: "@",
			adeReadonly: "@",
			ngModel: "="
		},

		//The link step (after compile)
		link: function(scope, element, attrs) {
			var editing=false;
			var input = null;
			var exit = 0; //0=click, 1=tab, -1= shift tab, 2=return, -2=shift return. controls if you exited the field so you can focus the next field if appropriate

			var readonly = false;
			var inputClass = "";
			var format = '12';
			var stringTime = ""; //The string displayed to the user after conversion from timestamp

			if(scope.adeTime!==undefined) format = scope.adeTime;
			if(scope.adeClass!==undefined) inputClass = scope.adeClass;
			if(scope.adeReadonly!==undefined && scope.adeReadonly=="1") readonly = true;

			var makeHTML = function() {
				if(scope.ngModel==undefined) stringTime = "";
				else stringTime = $filter('time')(scope.ngModel,format);
				element.html(stringTime);
			};

			//callback once the edit is done
			var saveEdit = function(exited) {
				var editedValue = input.val();
				var oldValue = scope.ngModel;
				exit = exited;

				if(exited!=3) { //don't save value on esc or no changes
					var arr = editedValue.split(' ');
					var hrsmin = arr[0].split(':');
					var hours = parseInt(hrsmin[0], 10);
					var mins = parseInt(hrsmin[1], 10);
					var ampm = arr[1] || '';
					var validHrs = (hours <= 23) ? hours : 23;
					var validMins = (mins <= 59) ? mins : 59;
					if(validMins<10) validMins = "0"+validMins;
					var cleanedValue = validHrs+":"+validMins+" "+ampm;

					scope.ngModel = (hrsmin.length > 1) ? Date.parse(cleanedValue).getTime() / 1000 : '';
				}

				element.show();

				ADE.teardownBlur(input);
				ADE.teardownKeys(input);

				scope.adePickTime = -2;
				input.remove(); //remove the input
				editing=false;

				ADE.done(scope.adeId, oldValue, scope.ngModel, exit);
			};

			var clickHandler = function(e) {
				ADE.hidePopup();
				if(editing) return;
				editing=true;
				exit = 0;

				scope.adePickTime = scope.ngModel || 0;
				var timeLength = 8;
				if (format === "24") timeLength = 5;

				ADE.begin(scope.adeId);

				element.hide();
				var html = '<input ade-timepop="'+format+'" ng-model="adePickTime" maxlength="'+timeLength+'" type="text" class="'+inputClass+'" />';
				$compile(html)(scope).insertAfter(element);
				input = element.next('input');

				input.focus(); //I do not know why both of these are necessary, but they are
				setTimeout(function() {
					input.focus();
				});

				ADE.setupBlur(input,saveEdit, scope);
				ADE.setupKeys(input,saveEdit, false, scope);
			};

			//handles clicks on the read version of the data
			if(!readonly) {
				element.on('click.ADE', clickHandler);
			}

			scope.$on('$destroy', function() { //need to clean up the event watchers when the scope is destroyed
				if(element) {
					element.off('click.ADE');
				}
				if(unwatch) unwatch();
			});

			//need to watch the model for changes
			var unwatch = scope.$watch(function(scope) {
				return scope.ngModel;
			}, function () {
				makeHTML();
			});
		}
	};
}]);


/*
 References

 https://groups.google.com/forum/?fromgroups=#!topic/angular/ERUVRR8vZW0
 http://www.eyecon.ro/bootstrap-timepicker/
 https://gist.github.com/3103533
 https://gist.github.com/3135128

 Alternative: https://github.com/angular-ui/angular-ui/tree/master/modules/directives/time

 http://docs.angularjs.org/guide/directive
 */
/* ==================================================================
	AngularJS Datatype Editor - Time
	A filter to display local time from a unix timestamp.
	
	Usage:
	{{ data | time }}
	{{ data | time:'12' }}
	{{ data | time:'24' }}

------------------------------------------------------------------*/

angular.module('ADE').filter('time', function() {
	return function(input, format) {
		var output = '';
		var format = format || "12";
		var date;
		var ampm;
		var hours;
		var minutes;
		
		if (angular.isUndefined(input)) return output;
		if (angular.isArray(input)) input = input[0];
		if (input==0) return output;
		if (angular.isNumber(input)) date = new Date(input*1000);
	
		if (angular.isString(input)) { //is it already formatted?
			var arr = input.split(' '); //[time,meridian?]
			if(arr[0].indexOf(":")==-1) return output; //not a time string
			var hrsmin = arr[0].split(':');//[hour,minute]
			var hours = parseInt(hrsmin[0], 10);
			var mins = parseInt(hrsmin[1], 10);
			var ampm = arr[1] || '';
			var validHrs = (hours <= 23) ? hours : 23;
			var validMins = (mins <= 59) ? mins : 59;
			if(validMins<10) validMins = "0"+validMins;
			var cleanedValue = validHrs+":"+validMins+" "+ampm;
			return cleanedValue;
		}

		if (!angular.isDate(date)) return output;
  
		hours = date.getHours();
		minutes = date.getMinutes();
		
		if (format === "12") {
			ampm = (hours >= 12) ? 'pm' : 'am';
			hours = hours % 12;
			hours = hours ? hours : 12;
			minutes = minutes < 10 ? '0'+minutes : minutes;
			output = hours + ":" + minutes + " " + ampm;
		} else {
			minutes = minutes < 10 ? '0'+minutes : minutes;
			output = hours + ":" + minutes;
		}

		return output;
	};
});

/* =========================================================
 * bootstrap-timepicker.js
 * http://www.github.com/jdewit/bootstrap-timepicker
 * =========================================================
 * Copyright 2012
 *
 * Created By:
 * Joris de Wit @joris_dewit
 *
 * Contributions By:
 * Gilbert @mindeavor
 * Koen Punt info@koenpunt.nl
 * Nek
 * Chris Martin
 * Dominic Barnes contact@dominicbarnes.us
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================= */
!function($) {

    /* TIMEPICKER PUBLIC CLASS DEFINITION
     * ================================== */
    var Timepicker = function(element, options) {
        this.$element = $(element);
        this.isInput = this.$element.is('input');
        this.options = $.extend({}, $.fn.timepicker.defaults, options, this.$element.data());
        this.minuteStep = this.options.minuteStep || this.minuteStep;
        this.secondStep = this.options.secondStep || this.secondStep;
        this.showMeridian = this.options.showMeridian || this.showMeridian;
        this.showSeconds = this.options.showSeconds || this.showSeconds;
        this.showInputs = this.options.showInputs || this.showInputs;
        this.disableFocus = this.options.disableFocus || this.disableFocus;
        this.template = this.options.template || this.template;
        this.modalBackdrop = this.options.modalBackdrop || this.modalBackdrop;
        this.defaultTime = this.options.defaultTime || this.defaultTime;
        this.open = false;
        this.init();
    };

    Timepicker.prototype = {

        constructor: Timepicker,
        init: function() {
            if (this.$element.parent()
                .hasClass('input-append')) {
                this.$element.parent('.input-append')
                    .find('.add-on')
                    .on('click', $.proxy(this.showWidget, this));
                this.$element.on({
                    focus: $.proxy(this.highlightUnit, this),
                    click: $.proxy(this.highlightUnit, this),
                    keypress: $.proxy(this.elementKeypress, this),
                    blur: $.proxy(this.blurElement, this)
                });

            } else {
                if (this.template) {
                    this.$element.on({
                        focus: $.proxy(this.showWidget, this),
                        click: $.proxy(this.showWidget, this),
                        blur: $.proxy(this.blurElement, this)
                    });
                } else {
                    this.$element.on({
                        focus: $.proxy(this.highlightUnit, this),
                        click: $.proxy(this.highlightUnit, this),
                        keypress: $.proxy(this.elementKeypress, this),
                        blur: $.proxy(this.blurElement, this)
                    });
                }
            }


            this.$widget = $(this.getTemplate())
                .appendTo('body');

            this.$widget.on({
                click: $.proxy(this.widgetClick, this),
                mousedown: $.proxy(this.mousedown, this)
            });

            if (this.showInputs) {
                this.picker = this.$widget.find('input')
                    .on({
                        click: function() {
                            this.select();
                        },
                        keypress: $.proxy(this.widgetKeypress, this),
                        change: $.proxy(this.updateFromWidgetInputs, this)
                    });
            }

            this.setDefaultTime(this.defaultTime);
        }

        ,
        showWidget: function(e) {
            e.stopPropagation();
            e.preventDefault();

            if (this.open) {
                return;
            }

            if (!this.isInput) {
                $(document).on('mousedown', $.proxy(this.hide, this));
            }

            this.$element.trigger('show');

            if (this.disableFocus) {
                this.$element.blur();
            }

            var pos = $.extend({}, this.$element.offset(), {
                height: this.$element[0].offsetHeight
            });

            this.updateFromElementVal();

            $('html')
                .trigger('click.timepicker.data-api')
                .one('click.timepicker.data-api', $.proxy(this.hideWidget, this));

            if (this.template === 'modal') {
                this.$widget.modal('show')
                    .on('hidden', $.proxy(this.hideWidget, this));
            } else {
                this.$widget.css({
                    top: pos.top + pos.height,
                    left: pos.left
                });

                if (!this.open) {
                    this.$widget.addClass('open');
                }
            }

            this.open = true;
            this.$element.trigger('shown');
        },

        hideWidget: function(saveData) {
            // added by toodledo: shouldSave (on hide) and time value
            var dateValue = Date.parse(this.$element.val());
            this.time = (dateValue !== null) ? dateValue.getTime()/1000 : '';
            this.save = (saveData) ? true : false;
            this.$element.trigger({
                type: 'hide',
                time: this.time,
                shouldSave : this.save
            });

            if (this.template === 'modal') {
                this.$widget.modal('hide');
            } else {
                this.$widget.removeClass('open');
            }
            this.open = false;
            this.$element.trigger('hidden');
        },

        mousedown: function(e) {
            e.stopPropagation();
            e.preventDefault();
        },

        removeWidget: function() {
            this.$widget.remove();
        },

        widgetClick: function(e) {
            e.stopPropagation();
            e.preventDefault();

            var action = $(e.target)
                .closest('a')
                .data('action');
            if (action) {
                this[action]();
                this.update();
            }
        }

        ,
        widgetKeypress: function(e) {
            var input = $(e.target)
                .closest('input')
                .attr('name');

            switch (e.keyCode) {
                case 9:
                    //tab
                    if (this.showMeridian) {
                        if (input == 'meridian') {
                            this.hideWidget();
                        }
                    } else {
                        if (this.showSeconds) {
                            if (input == 'second') {
                                this.hideWidget();
                            }
                        } else {
                            if (input == 'minute') {
                                this.hideWidget();
                            }
                        }
                    }
                    break;
                case 27:
                    // escape
                    this.hideWidget();
                    break;
                case 38:
                    // up arrow
                    switch (input) {
                        case 'hour':
                            this.incrementHour();
                            break;
                        case 'minute':
                            this.incrementMinute();
                            break;
                        case 'second':
                            this.incrementSecond();
                            break;
                        case 'meridian':
                            this.toggleMeridian();
                            break;
                    }
                    this.update();
                    break;
                case 40:
                    // down arrow
                    switch (input) {
                        case 'hour':
                            this.decrementHour();
                            break;
                        case 'minute':
                            this.decrementMinute();
                            break;
                        case 'second':
                            this.decrementSecond();
                            break;
                        case 'meridian':
                            this.toggleMeridian();
                            break;
                    }
                    this.update();
                    break;
                case 13:
                    // enter
                    this.updateElement();
                    this.hideWidget();
                    break;
            }
        }

        ,
        elementKeypress: function(e) {
            var input = this.$element.get(0);
            switch (e.keyCode) {
                case 0:
                    //input
                    break;
                case 9:
                    //tab
                    this.updateFromElementVal();
                    if (this.showMeridian) {
                        if (this.highlightedUnit != 'meridian') {
                            e.preventDefault();
                            this.highlightNextUnit();
                        }
                    } else {
                        if (this.showSeconds) {
                            if (this.highlightedUnit != 'second') {
                                e.preventDefault();
                                this.highlightNextUnit();
                            }
                        } else {
                            if (this.highlightedUnit != 'minute') {
                                e.preventDefault();
                                this.highlightNextUnit();
                            }
                        }
                    }
                    break;
                case 27:
                    // escape
                    this.updateFromElementVal();
                    break;
                case 37:
                    // left arrow
                    this.updateFromElementVal();
                    this.highlightPrevUnit();
                    break;
                case 38:
                    // up arrow
                    switch (this.highlightedUnit) {
                        case 'hour':
                            this.incrementHour();
                            break;
                        case 'minute':
                            this.incrementMinute();
                            break;
                        case 'second':
                            this.incrementSecond();
                            break;
                        case 'meridian':
                            this.toggleMeridian();
                            break;
                    }
                    this.updateElement();
                    break;
                case 39:
                    // right arrow
                    this.updateFromElementVal();
                    this.highlightNextUnit();
                    break;
                case 40:
                    // down arrow
                    switch (this.highlightedUnit) {
                        case 'hour':
                            this.decrementHour();
                            break;
                        case 'minute':
                            this.decrementMinute();
                            break;
                        case 'second':
                            this.decrementSecond();
                            break;
                        case 'meridian':
                            this.toggleMeridian();
                            break;
                    }
                    this.updateElement();
                    break;
            }

            if (e.keyCode !== 0 && e.keyCode !== 8 && e.keyCode !== 9 && e.keyCode !== 46) {
                e.preventDefault();
            }
        }

        ,
        setValues: function(time) {
            if (this.showMeridian) {
                var arr = time.split(' ');
                var timeArray = arr[0].split(':');
                this.meridian = arr[1];
            } else {
                var timeArray = time.split(':');
            }

            this.hour = parseInt(timeArray[0], 10);
            this.minute = parseInt(timeArray[1], 10);
            this.second = parseInt(timeArray[2], 10);

            if (isNaN(this.hour)) {
                this.hour = 0;
            }
            if (isNaN(this.minute)) {
                this.minute = 0;
            }

            if (this.showMeridian) {
                if (this.hour > 12) {
                    this.hour = 12;
                } else if (this.hour < 1) {
                    this.hour = 1;
                }

                if (this.meridian == 'AM' || this.meridian == 'A') {
                    this.meridian = 'am';
                } else if (this.meridian == 'PM' || this.meridian == 'P') {
                    this.meridian = 'pm';
                }

                if (this.meridian != 'am' && this.meridian != 'pm') {
                    this.meridian = 'am';
                }
            } else {
                if (this.hour >= 24) {
                    this.hour = 23;
                } else if (this.hour < 0) {
                    this.hour = 0;
                }
            }

            if (this.minute < 0) {
                this.minute = 0;
            } else if (this.minute >= 60) {
                this.minute = 59;
            }

            if (this.showSeconds) {
                if (isNaN(this.second)) {
                    this.second = 0;
                } else if (this.second < 0) {
                    this.second = 0;
                } else if (this.second >= 60) {
                    this.second = 59;
                }
            }

            if (this.$element.val() != '') this.updateElement();
            this.updateWidget();
        }

        ,
        setMeridian: function(meridian) {
            if (meridian == 'a' || meridian == 'am' || meridian == 'AM') {
                this.meridian = 'AM';
            } else if (meridian == 'p' || meridian == 'pm' || meridian == 'PM') {
                this.meridian = 'PM';
            } else {
                this.updateWidget();
            }

            this.updateElement();
        }

        ,
        setDefaultTime: function(defaultTime) {
            if (defaultTime) {
                if (defaultTime === 'current') {
                    var dTime = new Date();
                    var hours = dTime.getHours();
                    var minutes = Math.floor(dTime.getMinutes() / this.minuteStep) * this.minuteStep;
                    var seconds = Math.floor(dTime.getSeconds() / this.secondStep) * this.secondStep;
                    var meridian = 'am';
                    if (this.showMeridian) {
                        if (hours === 0) {
                            hours = 12;
                        } else if (hours >= 12) {
                            if (hours > 12) {
                                hours = hours - 12;
                            }
                            meridian = 'pm';
                        } else {
                            meridian = 'am';
                        }
                    }
                    this.hour = hours;
                    this.minute = minutes;
                    this.second = seconds;
                    this.meridian = meridian;
                } else if (defaultTime === 'value') {
                    this.setValues(this.$element.val());
                } else {
                    this.setValues(defaultTime);
                }
                if (this.$element.val() != '') this.updateElement();
                this.updateWidget();
            } else {
                this.hour = 0;
                this.minute = 0;
                this.second = 0;
            }
        }

        ,
        formatTime: function(hour, minute, second, meridian) {
            hour = hour; //updated to remove leading zero
            minute = minute < 10 ? '0' + minute : minute;
            second = second < 10 ? '0' + second : second;

            return hour + ':' + minute + (this.showSeconds ? ':' + second : '') + (this.showMeridian ? ' ' + meridian : '');
        }

        ,
        getTime: function() {
            return this.formatTime(this.hour, this.minute, this.second, this.meridian);
        }

        ,
        setTime: function(time) {
            this.setValues(time);
            this.update();
        }

        ,
        update: function() {
            this.updateElement();
            this.updateWidget();
        }

        ,
        blurElement: function() {
            this.highlightedUnit = undefined;
            this.updateFromElementVal();
        }

        ,
        updateElement: function() {
            var time = this.getTime();

            this.$element.val(time)
                .change();

            switch (this.highlightedUnit) {
                case 'hour':
                    this.highlightHour();
                    break;
                case 'minute':
                    this.highlightMinute();
                    break;
                case 'second':
                    this.highlightSecond();
                    break;
                case 'meridian':
                    this.highlightMeridian();
                    break;
            }
        }

        ,
        updateWidget: function() {
            if (this.showInputs) {
                this.$widget.find('input.bootstrap-timepicker-hour')
                    .val(this.hour); //updated to remove leading zero
                this.$widget.find('input.bootstrap-timepicker-minute')
                    .val(this.minute < 10 ? '0' + this.minute : this.minute);
                if (this.showSeconds) {
                    this.$widget.find('input.bootstrap-timepicker-second')
                        .val(this.second < 10 ? '0' + this.second : this.second);
                }
                if (this.showMeridian) {
                    this.$widget.find('input.bootstrap-timepicker-meridian')
                        .val(this.meridian);
                }
            } else {
                this.$widget.find('span.bootstrap-timepicker-hour')
                    .text(this.hour);
                this.$widget.find('span.bootstrap-timepicker-minute')
                    .text(this.minute < 10 ? '0' + this.minute : this.minute);
                if (this.showSeconds) {
                    this.$widget.find('span.bootstrap-timepicker-second')
                        .text(this.second < 10 ? '0' + this.second : this.second);
                }
                if (this.showMeridian) {
                    this.$widget.find('span.bootstrap-timepicker-meridian')
                        .text(this.meridian);
                }
            }
        }

        ,
        updateFromElementVal: function(e) {
            var time = this.$element.val();
            if (time) {
                this.setValues(time);
                this.updateWidget();
            }
        }

        ,
        updateFromWidgetInputs: function() {
            var time = $('input.bootstrap-timepicker-hour', this.$widget)
                .val() + ':' + $('input.bootstrap-timepicker-minute', this.$widget)
                .val() + (this.showSeconds ? ':' + $('input.bootstrap-timepicker-second', this.$widget)
                .val() : '') + (this.showMeridian ? ' ' + $('input.bootstrap-timepicker-meridian', this.$widget)
                .val() : '');

            this.setValues(time);
        }

        ,
        getCursorPosition: function() {
            var input = this.$element.get(0);

            if ('selectionStart' in input) {
                // Standard-compliant browsers
                return input.selectionStart;
            } else if (document.selection) {
                // IE fix
                input.focus();
                var sel = document.selection.createRange();
                var selLen = document.selection.createRange()
                    .text.length;
                sel.moveStart('character', - input.value.length);

                return sel.text.length - selLen;
            }
        }

        ,
        highlightUnit: function() {
            var input = this.$element.get(0);

            this.position = this.getCursorPosition();
            if (this.position >= 0 && this.position <= 2) {
                this.highlightHour();
            } else if (this.position >= 3 && this.position <= 5) {
                this.highlightMinute();
            } else if (this.position >= 6 && this.position <= 8) {
                if (this.showSeconds) {
                    this.highlightSecond();
                } else {
                    this.highlightMeridian();
                }
            } else if (this.position >= 9 && this.position <= 11) {
                this.highlightMeridian();
            }
        }

        ,
        highlightNextUnit: function() {
            switch (this.highlightedUnit) {
                case 'hour':
                    this.highlightMinute();
                    break;
                case 'minute':
                    if (this.showSeconds) {
                        this.highlightSecond();
                    } else {
                        this.highlightMeridian();
                    }
                    break;
                case 'second':
                    this.highlightMeridian();
                    break;
                case 'meridian':
                    this.highlightHour();
                    break;
            }
        }

        ,
        highlightPrevUnit: function() {
            switch (this.highlightedUnit) {
                case 'hour':
                    this.highlightMeridian();
                    break;
                case 'minute':
                    this.highlightHour();
                    break;
                case 'second':
                    this.highlightMinute();
                    break;
                case 'meridian':
                    if (this.showSeconds) {
                        this.highlightSecond();
                    } else {
                        this.highlightMinute();
                    }
                    break;
            }
        }

        ,
        highlightHour: function() {
            this.highlightedUnit = 'hour';
            this.$element.get(0)
                .setSelectionRange(0, 2);
        }

        ,
        highlightMinute: function() {
            this.highlightedUnit = 'minute';
            this.$element.get(0)
                .setSelectionRange(3, 5);
        }

        ,
        highlightSecond: function() {
            this.highlightedUnit = 'second';
            this.$element.get(0)
                .setSelectionRange(6, 8);
        }

        ,
        highlightMeridian: function() {
            this.highlightedUnit = 'meridian';
            if (this.showSeconds) {
                this.$element.get(0)
                    .setSelectionRange(9, 11);
            } else {
                this.$element.get(0)
                    .setSelectionRange(6, 8);
            }
        }

        ,
        incrementHour: function() {
            if (this.showMeridian) {
                if (this.hour === 11) {
                    this.toggleMeridian();
                } else if (this.hour === 12) {
                    return this.hour = 1;
                }
            }
            if (this.hour === 23) {
                return this.hour = 0;
            }
            this.hour = this.hour + 1;
        }

        ,
        decrementHour: function() {
            if (this.showMeridian) {
                if (this.hour === 1) {
                    return this.hour = 12;
                } else if (this.hour === 12) {
                    this.toggleMeridian();
                }
            }
            if (this.hour === 0) {
                return this.hour = 23;
            }
            this.hour = this.hour - 1;
        }

        ,
        incrementMinute: function() {
            var newVal = this.minute + this.minuteStep - (this.minute % this.minuteStep);
            if (newVal > 59) {
                this.incrementHour();
                this.minute = newVal - 60;
            } else {
                this.minute = newVal;
            }
        }

        ,
        decrementMinute: function() {
            var newVal = this.minute - this.minuteStep;
            if (newVal < 0) {
                this.decrementHour();
                this.minute = newVal + 60;
            } else {
                this.minute = newVal;
            }
        }

        ,
        incrementSecond: function() {
            var newVal = this.second + this.secondStep - (this.second % this.secondStep);
            if (newVal > 59) {
                this.incrementMinute();
                this.second = newVal - 60;
            } else {
                this.second = newVal;
            }
        }

        ,
        decrementSecond: function() {
            var newVal = this.second - this.secondStep;
            if (newVal < 0) {
                this.decrementMinute();
                this.second = newVal + 60;
            } else {
                this.second = newVal;
            }
        }

        ,
        toggleMeridian: function() {
            this.meridian = this.meridian === 'am' ? 'pm' : 'am';

            this.update();
        }

        ,
        getTemplate: function() {
            if (this.options.templates[this.options.template]) {
                return this.options.templates[this.options.template];
            }
            if (this.showInputs) {
                var hourTemplate = '<input type="text" name="hour" class="bootstrap-timepicker-hour" maxlength="2"/>';
                var minuteTemplate = '<input type="text" name="minute" class="bootstrap-timepicker-minute" maxlength="2"/>';
                var secondTemplate = '<input type="text" name="second" class="bootstrap-timepicker-second" maxlength="2"/>';
                var meridianTemplate = '<input type="text" name="meridian" class="bootstrap-timepicker-meridian" maxlength="2"/>';
            } else {
                var hourTemplate = '<span class="bootstrap-timepicker-hour"></span>';
                var minuteTemplate = '<span class="bootstrap-timepicker-minute"></span>';
                var secondTemplate = '<span class="bootstrap-timepicker-second"></span>';
                var meridianTemplate = '<span class="bootstrap-timepicker-meridian"></span>';
            }
            var templateContent = '<table class="' + (this.showSeconds ? 'show-seconds' : '') + ' ' + (this.showMeridian ? 'show-meridian' : '') + '">' + '<tr>' + '<td><a href="#" data-action="incrementHour"><i class="icon-chevron-up"></i></a></td>' + '<td class="separator"> </td>' + '<td><a href="#" data-action="incrementMinute"><i class="icon-chevron-up"></i></a></td>' + (this.showSeconds ? '<td class="separator"> </td>' + '<td><a href="#" data-action="incrementSecond"><i class="icon-chevron-up"></i></a></td>' : '') + (this.showMeridian ? '<td class="separator"> </td>' + '<td class="meridian-column"><a href="#" data-action="toggleMeridian"><i class="icon-chevron-up"></i></a></td>' : '') + '</tr>' + '<tr>' + '<td>' + hourTemplate + '</td> ' + '<td class="separator">:</td>' + '<td>' + minuteTemplate + '</td> ' + (this.showSeconds ? '<td class="separator">:</td>' + '<td>' + secondTemplate + '</td>' : '') + (this.showMeridian ? '<td class="separator"> </td>' + '<td>' + meridianTemplate + '</td>' : '') + '</tr>' + '<tr>' + '<td><a href="#" data-action="decrementHour"><i class="icon-chevron-down"></i></a></td>' + '<td class="separator"></td>' + '<td><a href="#" data-action="decrementMinute"><i class="icon-chevron-down"></i></a></td>' + (this.showSeconds ? '<td class="separator"> </td>' + '<td><a href="#" data-action="decrementSecond"><i class="icon-chevron-down"></i></a></td>' : '') + (this.showMeridian ? '<td class="separator"> </td>' + '<td><a href="#" data-action="toggleMeridian"><i class="icon-chevron-down"></i></a></td>' : '') + '</tr>' + '</table>';

            var template;
            switch (this.options.template) {
                case 'modal':
                    template = '<div class="bootstrap-timepicker modal hide fade in" style="top: 30%; margin-top: 0; width: 200px; margin-left: -100px;" data-backdrop="' + (this.modalBackdrop ? 'true' : 'false') + '">' + '<div class="modal-header">' + '<a href="#" class="close" data-dismiss="modal">×</a>' + '<h3>Pick a Time</h3>' + '</div>' + '<div class="modal-content">' + templateContent + '</div>' + '<div class="modal-footer">' + '<a href="#" class="btn btn-primary" data-dismiss="modal">Ok</a>' + '</div>' + '</div>';

                    break;
                case 'dropdown':
                    template = '<div class="bootstrap-timepicker dropdown-menu">' + templateContent + '</div>';
                    break;

            }
            return template;
        }
    };


    /* TIMEPICKER PLUGIN DEFINITION
     * =========================== */

    $.fn.timepicker = function(option, val) {
        return this.each(function() {
            var $this = $(this),
                data = $this.data('timepicker'),
                options = typeof option == 'object' && option;
            if (!data) {
                $this.data('timepicker', (data = new Timepicker(this, options)));
            }
            if (typeof option == 'string') {
                data[option](val);
            }
        });
    };

    $.fn.timepicker.defaults = {
        minuteStep: 15,
        secondStep: 15,
        disableFocus: false,
        defaultTime: 'current',
        showSeconds: false,
        showInputs: true,
        showMeridian: true,
        template: 'dropdown',
        modalBackdrop: false,
        templates: {} // set custom templates
    };

    $.fn.timepicker.Constructor = Timepicker;
}(window.jQuery);

/* ==================================================================
 AngularJS Datatype Editor - Toggle
 A directive to toggle a star, checkbox or other icon

 Usage:
 <a ade-toggle ade-id="1234" ade-class="ade-star" ng-model="data"></a>

Config:

ade-id:
	If this id is set, it will be used in messages broadcast to the app on state changes.
ade-class:
	A custom class to give to the div so that you can use your own images
ade-readonly:
	If you don't want the stars to be editable
ade-truthy:
	The value you want the model to have when the checkbox is checked. Defaults to true.

 Messages:
 name: ADE-start
 data: id from config

 name: ADE-finish
 data: {id from config, old value, new value}

 ------------------------------------------------------------------*/

angular.module('ADE').directive('adeToggle', ['ADE','$compile','$filter', function(ADE,$compile,$filter) {
	return {
		require: '?ngModel', //optional dependency for ngModel
		restrict: 'A', //Attribute declaration eg: <div ade-toggle=""></div>

		scope: {
			adeId: "@",
			adeClass: "@",
			adeReadonly: "@",
			adeTruthy: "@",
			ngModel: "="
		},

		//The link step (after compile)
		link: function(scope, element, attrs) {
			var starClass = "icon-star";
			var readonly = false;
			var truthy = true;

			if(scope.adeClass!==undefined) starClass = scope.adeClass;
			if(scope.adeReadonly!==undefined && scope.adeReadonly=="1") readonly = true;
			if(scope.adeTruthy!==undefined) truthy = scope.adeTruthy;
			
			//generates HTML for the star
			var makeHTML = function() {
				var input = scope.ngModel;
				if(angular.isArray(input)) input = input[0];
				if(angular.isString(input)) {
					input = input.toLowerCase();
					if(input=='false' || input=='no' || input=='0' || input=='o') input = false;
				}
				var editable = (readonly ? "" : " ade-editable");
				var state = (input==truthy ? '' : '-empty');

				var hoverable = " ade-hover";
				var userAgent = window.navigator.userAgent;
				if(userAgent.match(/iPad/i) || userAgent.match(/iPhone/i)) {
   				hoverable = ""; //iOS web views do a weird thing with hover effects on touch
				}

				element.html('<span class="ade-toggle '+editable+hoverable+' '+starClass+state+'">');
			}

			var clickHandler = function(e) {
				e.preventDefault();
				e.stopPropagation();

				ADE.begin(scope.adeId);

				var oldValue = scope.ngModel;

				if(scope.ngModel!=truthy) scope.ngModel = truthy;
				else scope.ngModel = false;

				ADE.done(scope.adeId, oldValue, scope.ngModel, 0);

				if($(element).is(':hover')) {
					//It would be nice to remove the hover effect until you leave and rehover
					//would need to register mouseout and touchmove events. yuck
				}
			};

			var focusHandler = function(e) {
				element.on('keypress.ADE', function(e) {
					if (e.keyCode == 13) { //return
						e.preventDefault();
						e.stopPropagation();
						element.click();
					}
				});
			};
			
			//setup events
			if(!readonly) {
				element.on('click.ADE', function(e) {
					scope.$apply(function() {
						clickHandler(e);
					})
				});
				element.on('focus.ADE',  function(e) {
					scope.$apply(function() {
						focusHandler(e);
					})
				});
				element.on('blur.ADE', function(e) {
					element.off('keypress.ADE');
				});
			}

			scope.$on('$destroy', function() { //need to clean up the event watchers when the scope is destroyed
				if(element) {
					element.off('click.ADE');
					element.off('focus.ADE');
					element.off('blur.ADE');
					element.off('keypress.ADE');
				}
			});
			
			//need to watch the model for changes
			scope.$watch(function(scope) {
				return scope.ngModel;
			}, function () {
				makeHTML();
			});

		}
	};
}]);
/* ==================================================================
	AngularJS Datatype Editor - URL
	A filter to display a string as a clickable URL.
	Wraps Angular's native linky filter so that we can handle more
	inputs
	
	Usage:
	{{ data | url }}

------------------------------------------------------------------*/

angular.module('ADE').filter('url', ['$filter',function($filter) {
	return function(input) {
		var output = '';
		var html = '';

		if(!input) return '';
		if(angular.isArray(input)) input = input[0];
		if(!angular.isString(input)) input = input.toString();
		
		input = $.trim(input);

		html = $filter('linky')(input);
		if (html==input) {
			if (input.indexOf(".") >= 0 && input.indexOf("http")!=0) {
				output = 'http://' + input;
				html = '<a href="' + output + '">' + output + '</a>';
			} else {
				html = input;
			}
		}

		return html;
	};
}]);

